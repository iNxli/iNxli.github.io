{"pages":[{"title":"","text":"sNmlTFLhdP","link":"/baidu_verify_sNmlTFLhdP.html"},{"title":"","text":"And then, there were none.","link":"/about/index.html"}],"posts":[{"title":"templates for icpc","text":"Hey, password is required here. 26542699060710c6e1e50807ee25ca350c4d07acf1cb183c4db8c8f1db1a2d8646e7133ed5e8c9506f102b6f6398e9644382f7c29f3197db66617bf7bb7d9d2d020fcbb3889b508889489bc8052b8ab55ddaf3e9aff62291502bf9f8d59001f333def924047277a99f14eafaecf811ed636a0e8019927db1cf2cdbb687b54878a2ec222a75ebc229092f504735687be1ef9944f72b2c96e8ecf8bea78121cad77f2500e80ac9e7c36af7645eb1ecb46f924925dff7f564446114a07ad68962642639ff73887e974d68f72ec9c03509d7fe5351aa392a55fdc07c26d7f78d9adf08b452c7380eeb3a97e9987f9062599da1bdd39f290cac856c7aaec777f772da09dd4ad7d71c05d701ad41fc84eb0e6f","link":"/Templates/templates-for-icpc/"},{"title":"褚遂良：雁塔圣教序","text":"唐太宗李世民圣教序 大唐三藏圣教序太宗文皇帝制 盖闻二仪有象，显覆载以含生。四时无形，潜寒暑以化物。是以窥天鉴地，庸愚皆识其端。明阴洞阳，贤哲罕穷其数。然而天地苞乎阴阳而易识者，以其有象也。阴阳处乎天地而难穷者，以其无形也。故知象显可征，虽愚不惑，形潜莫覩，在智者迷。况乎佛道崇虚，乘幽控寂，弘济万品，典御十方。举威灵而无上，抑神力而无下。大之则弥于宇宙，细之则摄于毫厘。无灭无生，历千劫而不古。若隐若显，运百福而长今。妙道凝玄，遵之莫知其际。法流湛寂，挹之则莫测其源。故知蠢蠢凡愚，区区庸鄙，投其旨趣，能无疑惑者哉？ 然则大教之兴，基乎西土。腾汉庭而皎梦，照东域而流慈。昔者分形分迹之时，言未驰而成化。当常现常之世，人仰德而知遵。及乎晦影归真，迁仪越世。金容掩色，不镜三千之光。丽象开图，空端四八之相。于是微言广被，拯含类于三途。遗训遐宣，导群生于十地。然而真教难仰，莫能一其指归，曲学易遵，邪正于焉纷糺。所以空有之论，或习俗而是非；大小之乘，乍沿时而隆替。 有玄奘法师者，法门之领袖也。幼怀贞敏，早悟三空之心；长契神情，先苞四忍之行。松风水月，未足比其清华；仙露明珠，讵能方其朗润。故以智通无累，神测未形。超六尘而迥出，只千古而无对。凝心内境，悲正法之陵迟；栖虑玄门，慨深文之讹谬。思欲分条析理，广彼前闻；截伪续真，开兹后学。是以翘心净土，往游西域；乘危远迈，杖策孤征。积雪晨飞，涂闲（间）失地；惊砂夕起，空外迷天。万里山川，拨烟霞而进影；百重寒暑，蹑霜雨而前踪。诚重劳轻，求深愿达。周游西宇，十有七年。穷历道邦，询求正教。双林八水，味道餐风；鹿菀鹫峰，瞻奇仰异。承至言于先圣，受真教于上贤。探赜妙门，精穷奥业。一乘五律之道，驰骤于心田；八藏三箧之文，波涛于口海。爰自所历之国，总将三藏要文，凡六百五十七部，译布中夏，宣扬胜业。引慈云于西极，注法雨于东垂。圣教缺而复全，苍生罪而还福。湿火宅之干焰，共拔迷途；朗爱水之昏波，同臻彼岸。是知恶因业坠，善以缘升，升坠之端，惟人所托。譬夫桂生高岭，云露方得泫其花；莲出渌波，飞尘不能污其叶。非莲性自洁，而桂质本贞，良由所附者高，则微物不能累；所凭者净，则浊类不能沾。夫以卉木无知，犹资善而成善；况乎人伦有识，不缘庆而求庆。方冀兹经流施，将日月而无穷。斯福遐敷，与乾坤而永大。 永徽四年，岁次癸丑十月己卯朔十五日癸巳建。 中书令臣褚遂良书。 唐高宗李治圣教序记 大唐皇帝述三藏圣教序记 夫显扬正教，非智无以广其文；崇阐微言，非贤莫能定其旨。盖真如圣教者，诸法之玄宗，众经之轨躅也。综括宏远，奥旨遐深。极空有之精微，体生灭之机要。词茂道旷，寻之者不究其源；文显义幽，理之者莫测其际。故知圣慈所被，业无善而不臻；妙化所敷，缘无恶而不翦。开法网之纲纪，弘六度之正教；拯群有之涂炭，启三藏之秘扃。是以名无翼而长飞，道无根而永固。道名流庆，历遂古而镇常；赴感应身，经尘劫而不朽。晨钟夕梵，交二音于鹫峰；慧日法流，转双轮于鹿菀。排空宝盖，接翔云而共飞；庄野春林，与天花而合彩。 伏惟皇帝陛下。上玄资福，垂拱而治八荒；德被黔黎，敛衽而朝万国。恩加朽骨，石室归贝叶之文；泽其昆虫，金匮流梵说之偈。遂使阿耨达水，通神甸之八川；耆阇崛山，接嵩华之翠岭。窃以法性凝寂，靡归心而不通；智地玄奥，感恳诚而遂显。岂谓重昏之夜，烛慧炬之光；火宅之朝，降法雨之泽。于是百川异流，同会于海；万区分义，总成乎实。岂与汤武校其优劣，尧舜比其圣德者哉？玄奘法师者，夙怀聪令，立志夷简。神清龆龀之年，体拔浮华之世。凝情定室，匿迹幽岩。栖息三禅，巡游十地。超六尘之境，独步伽维；会一乘之旨，随机化物。以中华之无质，寻印度之真文。远涉恒河，终期满字；频登雪岭，更获半珠。问道往还，十有七载。备通释典，利物为心。以贞观十九年九月六日奉敕于弘福寺，翻译圣教要文凡六百五十七部。引大海之法流，洗尘劳而不竭；传智灯之长焰，皎幽闇而恒明。自非久植胜缘，何以显扬斯旨。所谓法相常住，齐三光之明；我皇福臻，同二仪之固。伏见御制众经论序，照古腾今。理含金石之声，文抱风云之润。治辄以轻尘足岳，坠露添流。略举大纲，以为斯记。 皇帝在春宫日制此文。 永徽四年，岁次癸丑十二月戊寅朔十日丁亥建。 尚书仆射上柱国河南郡开国公臣褚遂良书。 万文韶刻字。","link":"/%E4%B9%A6%E6%B3%95/%E8%A4%9A%E9%81%82%E8%89%AF%EF%BC%9A%E9%9B%81%E5%A1%94%E5%9C%A3%E6%95%99%E5%BA%8F/"},{"title":"不能同生，我们就共死：计时引爆摩天楼","text":"正邪高手间的智商对决。 其实以前看电影的时候都没有很仔细，只是对一些场景和结果有比较深刻的印象。此部剧场版是柯南剧场版的开山之作，里面最后的那段镜头使得我对这部剧场版印象深刻。但似乎后来的评说者都并不是很看好这部电影，可能是由于其难以理解的犯罪动机且犯人一目了然吧。 但是我不这么认为，我认为这其实是很成功的一部电影，犯人确实是一目了然的，但是不是因为可供选择的犯人电影中就提到了一个，而是因为他的名字。柯南的动画是很喜欢玩弄假名和罗马音的，而电影中的头号犯罪嫌疑人，也就是建筑师——森谷帝二的前三个字森谷帝的平假名发音就是中文里的莫里亚蒂，而2可能就是想说他是第二个莫里亚蒂。因为他同莫里亚蒂一般富有才华，且聪明过人，最重要的是有超强的犯罪天赋。 影片一开始就已经在构建森谷的人设，追求完美，其原名为森谷贞治，由于贞治日语发音和帝二相同，便将其改为对称的帝二。值得一提的是，莫里亚蒂翻译成中文汉字其实也是对称的，但是日本人好像不会用汉字去翻译舶来语，他们一直都是直接用谐音的片假名代替。 影片开头还设置了一个悬念，就是为什么森谷要执着于工藤新一并且对他紧追不放。其实是由于工藤在之前一起案件中使得当时的支持森谷建筑设计的西多摩市市长锒铛入狱，而森谷的伟大设计（是他梦想中的城镇）就此化为泡影。而由此对工藤怀恨在心，而聪明过头的人并不想直接置对手于死地，而是想折磨他，特别是从他的长处入手，看他是否真的有那个能耐。而森谷给工藤的难题就是拆炸弹，并且每次提示都是以类似解谜的形式给出。 第一次没有涉及什么智力因素，可能是想让柯南和自己都热热身，然后不小心说话说得不好让柯南知道他有在远处监视并且不小心让少年侦探团看到自己易容的样子。（可能对手太聪明了后面也难搞，比如没有看到他易容这一说的话后面几乎不可能伪造证据让他说漏嘴自投罗网） 第二次又是一个谐音游戏，凶手给的提示是在树的下面，可能会被人捡走，而解决这个问题是因为树根的发音和猫（ねこ）近似，所以炸弹是在一个猫笼子里。 第三次则是最精彩的解谜部分，凶手给出的提示是在环状线上的列车在四点后必须以时速60公里以上行驶，否则将会有5颗塑料炸弹引爆，并且在太阳下山之后也会发生爆炸。而这个谜底我觉得很多人是想不到的，这需要充分考虑这两个引爆的条件，得出这是一种在阳光下计时就会重置，否则就会开始倒计时而引爆的炸弹，而炸弹就恰好装在铁轨之间，这样由于列车驶过车厢挡住光线将会使得炸弹开始倒计时，但是只要车速达到60公里每小时，就恰好可以在计时结束前驶离炸弹，那么重见阳光的炸弹计时就会重置。 而后面就是柯南推理凶手的过程（而我们根本不用推理也知道是谁，所以可以理解为柯南来填坑）。首先毛利展现其高光的一刻，他说犯人不会居住在刚刚拆除的炸弹附近，并且第二次拆炸弹时炸弹计时突然停止肯定也是因为这一点，可以说已经八九不离十了（实际情况是计时会停下来是旁边有象征森谷的新西多摩市的英式路灯）。最后柯南推理出森谷就是犯人其实只是以为他想炸毁自己30岁前那些不成熟的作品，并且把对自己的挑战作为障眼法，可最后在展览室看到西多摩市的城市构想图才发现他这是一个一石二鸟的方法！ 当然早期柯南是无限反转的，森谷还给工藤留下最后一个难题，就是最后要引爆的摩天楼。因为次日5月4日即为工藤的生日，电影从开头就一直不断暗示，而小兰则是约了他去看电影（叫红线的传说，而电影院理所当然就在摩天楼）并且要送他红衬衫（还是毛衣来着？），所以森谷要让他痛失至亲（这…），并且把爆炸时间设置为凌晨3分，让他体验3分钟的生日。 “Happy birthday，新一 因为 我想可能再也没有机会说这句话了” “剪吧，就剪你喜欢的那条吧 不用担心，如果真的躲不过的话，我会陪着你 不能同生，我们就共死” 当然最后小兰拆弹成功了，因为她不想剪掉系住她和新一的红线。 所以我觉得故事主要并不是想让观众享受推理和揪出犯人，而是想展示两人的智商对决。而森谷教授极度甚至接近病态的审美都在暗示着莫里亚蒂。森谷，不知道大家知不知道，在福尔摩斯探案集中出现莫里亚蒂的长篇故事叫做《恐怖谷》，当然我不知道日本“森”有没有恐怖的意思，但我觉得编剧可能有想到这点。而5月4日，其实就是福尔摩斯和莫里亚蒂在莱辛巴赫瀑布一起跌入谷底的日子，这里其实可能是在暗示工藤和森谷的最后一战，并且可以发现其结果取决因素和前面的三次不同，不是取决于工藤的智商，而是取决于兰。就是这样，既有纯粹的智商对决，又有无法预知的感情因素，才让情节更加丰富，富有人情味也更引人入胜。而最后森谷教授对于毛利兰成功拆弹更是目瞪口呆，他坚信她会剪断喜欢的红线，最后失败竟归结于自己过于聪明。 真乃：成也萧何，败也萧何。","link":"/Film/%E4%B8%8D%E8%83%BD%E5%90%8C%E7%94%9F%EF%BC%8C%E6%88%91%E4%BB%AC%E5%B0%B1%E5%85%B1%E6%AD%BB%EF%BC%9A%E8%AE%A1%E6%97%B6%E5%BC%95%E7%88%86%E6%91%A9%E5%A4%A9%E6%A5%BC/"},{"title":"CF Round #718 D","text":"D.Explorer Space Solution 注意到从每个点出去再返回的最优方案一定是到达最优中间的点然后原路返回, 所以预处理出花费 $k$ 可以到达 $(x,y)$ 的最短路, 用 $dis[x][y][k]$ 记录, 然后对每个点做一个类似背包的操作即可. 复杂度: $O(nmk^2)$. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include &lt;bits/stdc++.h&gt;#define INF (1e9 + 7)using namespace std;struct Node { int x, y, d;}p;const int MAX_N = 5e2 + 7;const int MAX_K = 13;int dis[MAX_N][MAX_N][MAX_K], col[MAX_N][MAX_N], row[MAX_N][MAX_N], dp[MAX_K];int n, m, k;void bfs() { queue&lt;Node&gt; q; for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) { for (int t = 1; t &lt;= k; ++t) { dis[i][j][t] = INF; } q.push({i, j, 0}); } } while (!q.empty()) { p = q.front(); q.pop(); int x = p.x, y = p.y, d = p.d; if (d == k) continue; if (x &gt; 1 &amp;&amp; dis[x][y][d] + col[x - 1][y] &lt; dis[x - 1][y][d + 1]) { dis[x - 1][y][d + 1] = dis[x][y][d] + col[x - 1][y]; q.push({x - 1, y, d + 1}); } if (x &lt; n &amp;&amp; dis[x][y][d] + col[x][y] &lt; dis[x + 1][y][d + 1]) { dis[x + 1][y][d + 1] = dis[x][y][d] + col[x][y]; q.push({x + 1, y, d + 1}); } if (y &gt; 1 &amp;&amp; dis[x][y][d] + row[x][y - 1] &lt; dis[x][y - 1][d + 1]) { dis[x][y - 1][d + 1] = dis[x][y][d] + row[x][y - 1]; q.push({x, y - 1, d + 1}); } if (y &lt; m &amp;&amp; dis[x][y][d] + row[x][y] &lt; dis[x][y + 1][d + 1]) { dis[x][y + 1][d + 1] = dis[x][y][d] + row[x][y]; q.push({x, y + 1, d + 1}); } }}int main() { scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt; m; ++j) { scanf(\"%d\", &amp;row[i][j]); } } for (int i = 1; i &lt; n; ++i) { for (int j = 1; j &lt;= m; ++j) { scanf(\"%d\", &amp;col[i][j]); } } if (k &amp; 1) { for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) { printf(\"-1 \"); } puts(\"\"); } } else { k /= 2; bfs(); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) { for (int t = 1; t &lt;= k; ++t) dp[t] = INF; for (int p = 0; p &lt;= k; ++p) { for (int q = p; q &lt;= k; ++q) { dp[q] = min(dp[q], dp[q - p] + dis[i][j][p]); } } printf(\"%d \", dp[k] &lt;&lt; 1); } puts(\"\"); } } return 0;}","link":"/%E5%9B%BE%E8%AE%BA/cf-round-718-d/"},{"title":"因为我喜欢你，我比任何人 都喜欢你: 瞳孔中的暗杀者","text":"发现早期的柯南剧场版构思总是十分细腻，首尾呼应，暗藏伏笔。 开头便是两位刑警连续被刺杀，唯一知道的是凶手用左手开枪，死亡讯息是用手紧紧抓住了左胸口。影片中在此情况的目暮警官甚至连毛利小五郎也不愿意透露半点消息，可见事态之严重，罪犯有极大概率是与警视厅相关的大人物！影片的开头廖廖几个镜头便渲染了这种紧张且较为沉重的氛围。 主要事件是在饭店发生的，经过前两起事件，目暮警官已经知晓佐藤警官极可能成为下一个受害者。交代好人物及事件背景后事件就发生了，犯人事先在女洗手间的置物柜中放了一把开着的手电筒，然后趁佐藤警官进去补妆的空隙利用移动电话装置使整层楼停电，这时候手电筒的光就会从置物柜中透出，那么人就会理所当然打开将其取出，凶手在这时便能放冷箭。（这时候犯人智商还是非常高的！）并且为了在事后不被测出硝烟反应，凶手利用雨伞将硝烟挡在了身前。所以后来现场所有人都没有测出硝烟反应。 然而本天衣无缝的计谋还是失算了。小兰在这时也去了洗手间，且恰好是小兰拿起了手电，而千钧一发之际佐藤自然是（不是）为小兰挡枪，而在惊慌中脱手的手电也照亮了凶手的脸！何谓“瞳孔的暗杀者”？恰当好处啊！真的是忍不住想要吐槽，前面的剧场版和后面的级别差太多了！前面直接看电影名都知道水平高超，而后面就是“颜色”+“莫名其妙的事物”。（绀青之拳… 纯黑（琴酒）的噩梦…）而此处，瞳孔一词指明了凶手的动机就是因为看到了凶手的长相，而配用暗杀者就直接上档次，既然是看得到的人，为何又成了暗杀者？这点在剧中其实得到了非常大的突出，暗杀不仅仅是看不到凶手，而且凶手就是眼前为自己细心治疗的心理医生！拍案，以为绝妙！ 可能由于惊吓，及对佐藤警官的愧疚，小兰失忆了。因为一些原因，白鸟的心理医生成了小兰的主治医师，也就是凶手，当然凶手还是容易猜的，因为表现得越有嫌疑的越不是凶手。遵循完美主义的凶手当然不会轻易放过小兰，小兰回家后的第一次外出便被直接从地铁站台被推下，然后柯南一个迅雷不及掩耳跳下去解救了小兰！作为电影，特技理应当是要有的，况且是推理题材，不来点动作还是比较容易沉闷与枯燥的。不过这一情节并非有意无意，而是为了后面去新兰最后一次约会的热带公园找寻记忆做铺垫，作为因为连累他人受伤而自闭的小兰自然不想让会为了她冲出地铁站台的柯南陪她一起去。 最后自然就是故事的高潮：热带公园。首先所有犯罪嫌疑人都会到达热带公园准备接受审判，然后柯南先被安排出去理解一下消除硝烟反应的小花招，然后每个人都很乖地给他提供信息，然后成功破案。然后再是毛利小五郎等使用毛利排除法成功抓住假犯人，把所有工具人全部支开，最后！就是柯南的柯学秀了！先是一波正常的你追我赶，开枪射不中，然后犯人对高智商小学生很感兴趣，先听他仔细分析一波，然后继续你追我赶，最后都要射杀了再来个看你有什么遗言之类的类似环节，然后gg，并被逮捕。 当然高潮部分不是由于犯人突然弱智产生的，而是由一些镜头砌成的。最后犯人会gg很大一个原因是因为广场上两小时一次的喷泉，使他无法正常地射击，而这在电影一开始便做好了铺垫，新一送给小兰获得空手道优胜奖的礼物，就是热带公园的喷泉，“你不是最喜欢看喷泉了吗？”而柯南想到这点并不是信手拈来，而是新一之前用冰可乐去贴小兰的脸，让小兰印象深刻并且通过电话告诉了柯南，而最后天才选手犯人自然是要射不中就算了还要射中园子给小兰买的可乐而因为小兰对可乐这一幕留有深刻印象而不舍得喝掉将其放到包里，啊自然柯南就想到了嘛。我只能说，水平很高！还有另外一个推向高潮的情节就是，名场面： “你说 为什么，你为什么要拼了命的保护我呢？” “因为我喜欢你 当然是因为我喜欢你 我比任何人 都喜欢你” 给我嗑！而这句话，并不由柯南首创，影片借由婚宴（好像不是，类似的东西）预新娘问起妃英理当时毛利怎么求婚的，竟然就是： “我喜欢你，我比地球上任何人都喜欢你” 拊掌，以为绝妙。 这部没有多线索并行，主要围绕一起事件展开。不过情节连贯，首尾呼应，犯人动机在理解范围之内，犯罪手法水准很高。此外，影片本是给一人一种警视厅有内幕的感觉，但其实确实暗示了一些高层的私心和不合法的势力范围波及，可能有在暗示什么，不想深究这点了。 最后完美的小松未步的片尾曲《因为有你》，影片落下帷幕。唯美动人：因为有你，我变得坚强。","link":"/Film/%E5%9B%A0%E4%B8%BA%E6%88%91%E5%96%9C%E6%AC%A2%E4%BD%A0%EF%BC%8C%E6%88%91%E6%AF%94%E4%BB%BB%E4%BD%95%E4%BA%BA-%E9%83%BD%E5%96%9C%E6%AC%A2%E4%BD%A0-%E7%9E%B3%E5%AD%94%E4%B8%AD%E7%9A%84%E6%9A%97%E6%9D%80%E8%80%85/"},{"title":"Eratosthenes筛法: 素数能有多奇妙","text":"… 引言 刚接触素数的定义, 便有了问题: 如何判断一个数是不是素数以及怎么获得一个区间内的素数. 古希腊学者Eratosthenes发明了一个获取区间素数的方法, 其亦出现在笔者的小学课本中. 方法是这样的, 把要生成素数的区间 $1,2,\\ldots,n$ 按顺序排列写成一张表. 先把 $1$ 去掉, 从 $2$ 开始, 由小至大, 若当前数未被划去, 则其是一个素数, 然后将其所有倍数在数表中划去, 最后表中未被划去的所有数即为此区间的所有素数. 这样做的原因是什么呢? 其实判断一个数是否为素数和获得区间内的素数是不太一样的, 显然第一个问题解决亦解决了第二个问题, 但是朴素判断一个数是不是素数的复杂度是 $O(\\sqrt{n})$ 的, 将其用于第二个问题将使得问题解决需要 $O(n\\sqrt{n})$. 而素数是不能有非平凡的因子的, 而合数的因子必然在比它小的位置出现, 也就是说既然素数不是这么好判断, 那么就将合数全部排除算了. 故曰: 筛法. 但是其实很多人都知道Eratosthenes筛法(下称埃氏筛)复杂度并不是非常优秀. 首先这样的一个算法看上去显然是有 $O(n\\log n)$ 的, 而大家所熟知的欧拉线性筛是 $O(n)$ 的. 但实际情况是埃氏筛是 $O(n\\log \\log n)$ 的, 并且基于这样一个&quot;筛&quot;的想法可以引出一些适用于其他问题的好方法, 例如求一个大区间内素数函数和. 改良与素数函数前缀和的计算 可以发现, 一个数如果是合数, 必然有一个小于等于其平方根的素数, 所以我们只需要在 $\\sqrt{n}$ 下进行埃氏筛即可. 而如果只是要求一个素数函数的前缀和而不是具体是哪些素数的话, 则可以有更优的方法. 记素数函数(一个多项式函数, 易于直接求解前缀和) $f(n)$, 记 $g(n,j)$ 定义如下: $$ g(n,j)=\\sum_{i=1}^{n}[i\\in P\\text{或i的最小素因子}>p_j] $$ $P$ 是素数集合, $p_j$ 表示第 $j$ 个素数. 那么我们所要求的就是 $g(n, \\vert P\\vert)$. 这样做的目的就是想要利用埃氏筛的思想, 用前 $\\sqrt{n}$ 的素数去将后面的合数筛去. 其具体的转移是这样的, 如果 $p_j^2&gt;n$, 那么 $g(n,j)=g(n,j-1)$. 这是因为有 $p_j$ 这个素因子的合数必然有一个比 $p_j$ 更小的, 那么在 $j$ 此前已被筛去, 所以在这一步没有多余的操作. 而对于 $p_j^2\\leq n$ 的情况, 就需要把以 $p_j$ 为最小素因子的数筛去. 而这些数源于何处? 因为是最小的素因子, 故可以将 $p_j$ 除掉然后在剩下的数中找寻最小素因子大于 $p_{j-1}$ 的数, 其再乘上 $p_j$ 即为要筛去的数. 而这是什么? 这就是: $g(n/p_{j},j-1)$! 但是其实还有点问题, 那就是 $g(n/p_j,j-1)$ 不止有那些最小素因子大于 $p_{j-1}$ 的还有一些比 $p_j$ 小的素数, 这些显然不能被一起考虑在内. 所以转移应该是: $$ g(n,j)=g(n,j-1)-f(p_j)\\left(g(\\frac{n}{p_j},j-1)-\\sum_{i=1}^{j-1}f(p_i)\\right) $$ 此处 $f(n)=n^k$, 对于一般的多项式就是多算几次, 然后合并就可以了. 并且注意到所以被用到的 $g(n’,j)$ 中 $n’=\\lfloor\\frac{n}{i}\\rfloor$, 所以只有 $O(\\sqrt n)$ 种, 而 $j$ 这一维可以用滚动数组&quot;滚掉&quot;. 利用素数分布的结果可以知道这个算法复杂度是: $O(\\frac{n}{\\log n})$, 这其实也就是 min_25 筛的第一步. 复杂度的证明 可以直接看论文: Merten’s Theorem 天才数学家Merten证明了: $$ \\sum_{p\\leq x}\\frac{1}{p}=\\ln\\ln[x]+\\gamma+\\sum_{m=2}^{\\infty}\\mu(m)\\frac{\\ln(\\zeta(m))}{m}+\\delta $$ 而仅想证明埃氏筛复杂度是 $O(n\\log \\log n)$ 的话只需要知道素数倒数和与 $\\log \\log n$ 是同阶的就可以了. 阿贝尔分部求和 首先简单说一下阿贝尔分部求和公式, 若有整数函数 $a(i)$ 和可导函数 $f(i)$, 而 $A(x):=\\sum_{i\\leq x}a(i)$, 那么有: $$ \\begin{align*} a(i)f(i)&=A(i)f(i)-A(i-1)f(i)\\\\ &=A(i)f(i)-A(i-1)f(i-1)+A(i-1)(f(i)-f(i-1))\\\\ &=A(i)f(i)-A(i-1)f(i-1)+\\int_{i-1}^{i}A(t)f'(t)\\mathrm{d}t \\end{align*} $$ 两边同时求和即得到: $$ \\sum_{y&lt;i\\leq x} a(i)f(i)=A(x)f(x)-A(y)f(y)-\\int_{y}^xA(t)f’(t)\\mathrm{d}t $$ 此即为阿贝尔分部求和公式, 其实也就是分部积分的离散形式. 证明的第一个途径 简单的, 可以令: $$ a(i):= \\begin{cases} 1,i=p\\\\ 0,others \\end{cases} $$ 而 $f(i):=\\frac{1}{i}$, 利用阿贝尔求和公式: $$ \\sum_{p\\leq x}\\frac{1}{p}=\\frac{\\pi(x)}{x}+\\int_{2}^{x}\\frac{\\pi(t)}{t^2}\\mathrm{d}t $$ 我们知道当 $x$ 很大的时候有: $\\pi(x)\\sim \\frac{x}{\\log x}$, 所以上面的阶数大致就是: $$ \\int_{2}^{x}\\frac{1}{t\\log t}\\mathrm{d}t=\\log \\log x $$ 但还有一种更加&quot;精确&quot;的方法, 令: $$ a(i):= \\begin{cases} \\frac{\\ln p}{p},i=p\\\\ 0,others \\end{cases} $$ 而 $f(i):=\\frac{1}{\\ln i}$, 那么有: $$ \\sum_{p\\leq x}\\frac{1}{p}=\\frac{A(x)}{\\ln x}+\\int_{2}^x\\frac{A(t)}{t(\\ln t)^2}\\mathrm{d}t $$ 而天才数学家Merten又证明了一下引理: $$ \\sum_{p\\leq x}\\frac{\\ln p}{p}=\\ln x+R(x) $$ 其中余项 $\\vert R(x)\\vert &lt;2$! 由此得到的界会比上一种方法来得&quot;紧&quot;. 当然这和我们考虑的复杂度没有太大关系. 由此: $$ \\begin{align*} \\sum_{p\\leq x}\\frac{1}{p}&=\\frac{\\ln x+R(x)}{\\ln x}+\\int_{2}^{x}\\frac{\\ln t+R(t)}{t\\ln^2 t}\\mathrm{d}t\\\\ &=1+\\frac{R(x)}{\\ln x}+\\ln\\ln x-\\ln\\ln 2 +\\int_{2}^x\\frac{R(t)}{t\\ln^2 t}\\mathrm{d}t-\\int_{x}^{\\infty}\\frac{R(t)}{t\\ln^2 t}\\mathrm{d}t\\\\ &=\\ln\\ln x+B+\\delta \\end{align*} $$ 其中, $B=1-\\ln \\ln 2+\\int_{2}^{\\infty}\\frac{R(t)}{t\\ln^2t}\\mathrm{d}t$, 是一个常数, 而: $$ \\delta=\\frac{R(x)}{\\ln x}-\\int_{x}^{\\infty}\\frac{R(t)}{t\\ln^2t}\\mathrm{d}t $$ 并且由 $\\vert R(x)\\vert &lt;2$ 可以知道: $\\vert \\delta\\vert&lt;\\frac{4}{\\ln x}$. 证明的第二个途径 参考OI Wiki: 筛法. 个人感觉不是非常严谨, 利用的是: $$ \\sum_{i=1}^{\\infty}\\frac{1}{i}=\\prod_{p}\\frac{p}{p-1} $$ 这当然又是天才欧拉的结论. 结语 其实越是经典的东西, 越是犀利, 越是值得思考与回味. 可能不只是学科如此, 可能许多人事亦是如此吧.","link":"/%E6%95%B0%E8%AE%BA/eratosthenes%E7%AD%9B%E6%B3%95-%E7%B4%A0%E6%95%B0%E8%83%BD%E6%9C%89%E5%A4%9A%E5%A5%87%E5%A6%99/"},{"title":"CF Round #717(Div.2)","text":"… C. Baby Ehab Partitions Again 因为这题差点gg… 因为自己推式子大意了啊… 要找奇数才是靠谱的… (不是什么最小值) D. Cut Solution 对于每个区间其实都可以贪心地考虑, 不过这样复杂度是 $O(nq)$ 的. 为此考虑从每个点 $i$ 开始的一个区间最远能覆盖到的点, 那么每次循环就是逐一往后&quot;跳&quot;, 太慢了… 所以自然地考虑倍增即可. 对于如何查找最远能到达的点, 注意到 $i+1$ 的答案不会比 $i$ 的来得小, 所以可以类似用双指针的想法(其实也不用…). 从后面往前计算答案, 加入一个新的点, 往后找到最近的有公共因子的数(可以预处理素因子), 然后和 $i+1$ 的答案求一个最小值. 时间复杂度: $O(q\\log n + n\\log n)$. Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 1e5 + 7;int a[MAX_N], dp[MAX_N][21], pos[MAX_N];bool vis[MAX_N];vector&lt;int&gt; p[MAX_N];int n, q;int main() { scanf(\"%d%d\", &amp;n, &amp;q); int N = 0; for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), N = max(N, a[i]); for (int i = 2; i &lt;= N; ++i) { if (vis[i]) continue; for (int j = i; j &lt;= N; j += i) { vis[j] = true; p[j].push_back(i); } } for (int i = 0; i &lt;= N; ++i) pos[i] = n + 1; dp[n + 1][0] = n + 1; for (int i = n; i; --i) { int mn = dp[i + 1][0]; for (auto pri : p[a[i]]) { mn = min(pos[pri], mn); pos[pri] = i; } dp[i][0] = mn; } for (int i = 1; i &lt;= 18; ++i) { for (int j = 1; j &lt;= n + 1; ++j) { dp[j][i] = dp[dp[j][i - 1]][i - 1]; } } while (q--) { int l, r; scanf(\"%d%d\", &amp;l, &amp;r); int now = l, ans = 0; for (int i = 18; i &gt;= 0; --i) { if (dp[now][i] &lt;= r) ans += (1 &lt;&lt; i), now = dp[now][i]; } printf(\"%d\\n\", ans + 1); } return 0;} E. Babay Ehab Plays with Permutation Solution 没看懂题解啥意思… 利用递推的方法, 用 $f[i][k]$ 表示取了 $i$ 个, 用了 $k$ 次对换的置换数. 有递推式: $$ f[i][k]=f[i-1][k]+(i-1)*f[i-1][k-1] $$ 注意到这样是 $O(nk)$ 的. 注意 $k$ 很小, 可能是利用矩阵. 写出 $f[i][k],f[i][k-1],\\ldots,f[i][0]$ 的线性递推的矩阵: $$ \\begin{pmatrix} 1&(i-1)&0&\\ldots&0\\\\ 0&1&(i-1)&\\ldots&0\\\\ \\vdots\\\\ 0&\\ldots&\\ldots&\\ldots&1\\\\ \\end{pmatrix} $$ 可以将其写成 $I+J(i-1)$. 然后全部乘起来就是: $$ (I+J(n-1))(I+J(n-2))(I+J(n-3))\\ldots(I+J(2)) $$ 可以发现任何矩阵与 $J$ 相乘会向右上角移动一个&quot;单位&quot;. 所以主对角线上的元素就是全部的 $I$ 相乘, 也就是 $1$. 而往右上角走一格的斜线上, 就是 $\\sum_{i=2}^{n-1} i$. 可以发现就是离对角线有 $k$ 个单位的话就是: $$ \\sum_{1&lt;i_1,i_2,\\ldots,i_k&lt;n \\text{且}i_x\\neq i_y(x\\neq y)}\\prod_{t=1}^k{i_t} $$ 然后利用容斥原理计算这个答案, 记为 $g[k]$, 则有: $$ g[k]=(2+\\ldots+n)g[k-1]-(2^2+\\ldots+n^2)g[k-2]+\\ldots+(-1)^{k-1}(2^k+\\ldots+n^k)g[0] $$ 所以要计算 $k$ 阶等差数列, 利用伯努利数进行计算. 复杂度大概是个 $O(k^3\\log MOD)$ 的. Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MOD = 1e9 + 7;const int MAX_K = 2e2 + 7;int b[MAX_K], c[MAX_K][MAX_K], mul[MAX_K], fac[MAX_K];int n, k, ans;int f_pow(int base, int b, int mod = MOD) { int res = 1; while (b) { if (b &amp; 1) res = res * base % mod; base = base * base % mod; b &gt;&gt;= 1; } return res;}void init(int k) { b[0] = 1, c[0][0] = 1; for (int i = 1; i &lt;= k + 1; ++i) { c[i][0] = 1; for (int j = 1; j &lt;= i; ++j) { c[i][j] = (c[i - 1][j] + c[i - 1][j - 1]) % MOD; } } for (int i = 1; i &lt;= k; ++i) { for (int j = 0; j &lt; i; ++j) { b[i] = (b[i] - b[j] * c[i + 1][j] % MOD) % MOD; } b[i] = b[i] * f_pow(i + 1, MOD - 2) % MOD; }}int s(int n, int p) { int res = 0; for (int i = 0; i &lt;= p; ++i) { res = (res + c[p + 1][i] * b[i] % MOD * f_pow(n, p + 1 - i) % MOD) % MOD; } return (res * f_pow(p + 1, MOD - 2) % MOD - 1) % MOD;}signed main() { scanf(\"%lld%lld\", &amp;n, &amp;k); init(201); mul[0] = 1; for (int i = 1; i &lt;= k; ++i) { int flag = 1; for (int j = 1; j &lt;= i; ++j) { mul[i] = (mul[i] + flag * (mul[i - j] * s(n, j)) % MOD) % MOD; flag = -flag; } mul[i] = mul[i] * f_pow(i, MOD - 2) % MOD; // printf(\"%lld\\n\", mul[i]); } for (int i = 1; i &lt;= k; ++i) { int ans = 0; for (int j = 0; j &lt;= i; ++j) { ans = (ans + mul[j]) % MOD; } printf(\"%lld \", (ans + MOD) % MOD); } puts(\"\"); return 0;}","link":"/CF/cf-round-717-div-2/"},{"title":"SDOI 2014 数表","text":"P3312 [SDOI2014] 数表 化简式子得到: $$ \\sum_{t=1}^{\\min\\{n,m\\}}\\lfloor \\frac{n}{i}\\rfloor\\lfloor\\frac{m}{i}\\rfloor (\\mu * f)(t) $$ 其中, $$ f(n)= \\begin{cases} \\sigma(n),\\sigma(n)\\leq a\\\\ 0,others\\\\ \\end{cases} $$ 然后离线处理, 把 $\\sigma$ 和询问的 $a$ 按从小到大排序, 逐个将 $\\sigma$ 加入, 为此, 用一个树状数组维护前缀和. 复杂度: $O(\\log n (\\sqrt{m}+\\sqrt{n}) + n\\log^2 n)$. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;struct Node { int num, idx; Node() {} bool operator&lt;(const Node &amp;u) { return num &lt; u.num; }};const int MAX_N = 1e5 + 7;const int MOD = 1ll &lt;&lt; 31;int pri[MAX_N], mu[MAX_N], x[MAX_N], y[MAX_N], ans[MAX_N], t[MAX_N], bit[MAX_N];Node sigma[MAX_N], a[MAX_N];int Q, n, m, cnt, N = 1e5;int f_pow(int base, int b, int mod = MOD) { int res = 1; while (b) { if (b &amp; 1) res = res * base % mod; base = base * base % mod; b &gt;&gt;= 1; } return res;}void Euler(int n) { mu[1] = 1; sigma[1].idx = 1, sigma[1].num = 1; for (int i = 2; i &lt;= n; ++i) { if (!sigma[i].num) { pri[++cnt] = i; mu[i] = -1; sigma[i].num = 1 + i; sigma[i].idx = i; t[i] = 1 + i; } for (int j = 1; j &lt;= cnt &amp;&amp; i * pri[j] &lt;= n; ++j) { if (i % pri[j] == 0) { mu[i * pri[j]] = 0; sigma[i * pri[j]].num = sigma[i].num / t[i] * (t[i] * pri[j] + 1); sigma[i * pri[j]].idx = i * pri[j]; t[i * pri[j]] = t[i] * pri[j] + 1; break; } mu[i * pri[j]] = -mu[i]; sigma[i * pri[j]].num = sigma[i].num * (pri[j] + 1); sigma[i * pri[j]].idx = i * pri[j]; t[i * pri[j]] = 1 + pri[j]; } }}inline int lowbit(const int &amp;x) { return x &amp; (-x); }void add(int x, int d) { for (; x &lt;= N; x += lowbit(x)) bit[x] = (bit[x] + d) % MOD;}int get_sum(int x) { int res = 0; for (; x; x -= lowbit(x)) res = (res + bit[x]) % MOD; return res;}int num_sqrt(int num, int n, int m) { int mn = min(n, m), res = 0; for (int i = 1, j; i &lt;= mn; i = j + 1) { j = min(n / (n / i), m / (m / i)); res = ((get_sum(j) - get_sum(i - 1)) * (n / i) % MOD * (m / i) % MOD + res) % MOD; } return res;}signed main() { Euler(1e5); scanf(\"%lld\", &amp;Q); for (int i = 1; i &lt;= Q; ++i) { scanf(\"%lld%lld%lld\", x + i, y + i, &amp;a[i].num); a[i].idx = i; } sort(a + 1, a + 1 + Q); int q = 1; sort(sigma + 1, sigma + 1 + N); for (int i = 1; i &lt;= N; ++i) { while (q &lt;= Q &amp;&amp; a[q].num &lt; sigma[i].num) { int id = a[q].idx; ans[id] = (num_sqrt(a[q].num, x[id], y[id]) + MOD) % MOD; ++q; } int id = sigma[i].idx; for (int u = id; u &lt;= N; u += id) { add(u, sigma[i].num * mu[u / id]); } } for (int i = 1; i &lt;= Q; ++i) printf(\"%lld\\n\", ans[i]); return 0;}","link":"/%E6%95%B0%E8%AE%BA/sdoi-2014-%E6%95%B0%E8%A1%A8/"},{"title":"CF Round #716(Div.2)","text":"… C. Product 1 Modulo N 据说是广义的wilson定理, 但是找找规律也可以搞吧. 因为互素就有逆元, 特别处理一下逆元是自身的, 这种情况后面恰好有一个数 $(n-x)$ 和它搭配为 $-1$, 最后考虑有几个这样的对, 判断要不要将 $n-1$ 加入即可. D. Cut and Stick Solution 结论是 $\\max\\{1, 2f-(r-l+1)\\}$ , $f$ 是区间众数. 然后这里是用一种题解说的线段树做法做的, 因为出现次数只有大于半数的众数才是有贡献的. (另外还可以用随机做法, 很神奇) Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#define pii pair&lt;int, int&gt;using namespace std;const int MAX_N = 3e5 + 7;vector&lt;int&gt; pos[MAX_N];int seg[MAX_N &lt;&lt; 2], a[MAX_N];int n, q;int cnt(int l, int r, int col) { if (!col) return 0; return (upper_bound(pos[col].begin(), pos[col].end(), r) - lower_bound(pos[col].begin(), pos[col].end(), l));}void pushup(int u, int l, int r) { seg[u] = (cnt(l, r, seg[u &lt;&lt; 1]) &lt; cnt(l, r, seg[u &lt;&lt; 1 | 1])) ? seg[u &lt;&lt; 1 | 1] : seg[u &lt;&lt; 1];}void build(int u, int l, int r) { if (l == r) { seg[u] = a[l]; return; } int mid = (l + r) &gt;&gt; 1; build(u &lt;&lt; 1, l, mid); build(u &lt;&lt; 1 | 1, mid + 1, r); pushup(u, l, r);}int query(int u, int l, int r, int x, int y) { if (x &lt;= l &amp;&amp; r &lt;= y) { return seg[u]; } int mid = (l + r) &gt;&gt; 1, res = 0, rx = 0, ry = 0; if (x &lt;= mid &amp;&amp; y &gt;= l) rx = query(u &lt;&lt; 1, l, mid, x, y); if (y &gt; mid &amp;&amp; x &lt;= r) ry = query(u &lt;&lt; 1 | 1, mid + 1, r, x, y); res = cnt(x, y, rx) &gt; cnt(x, y, res) ? rx : res; res = cnt(x, y, ry) &gt; cnt(x, y, res) ? ry : res; return res;}int main() { scanf(\"%d%d\", &amp;n, &amp;q); for (int i = 1; i &lt;= n; ++i) { scanf(\"%d\", a + i); pos[a[i]].push_back(i); } build(1, 1, n); while (q--) { int l, r; scanf(\"%d%d\", &amp;l, &amp;r); int k = cnt(l, r, query(1, 1, n, l, r)); printf(\"%d\\n\", max(1, k * 2 - (r - l + 1))); } return 0;} E. Baby Ehab’s Hyper Apartment Solution 考虑用二分的方法找到一条Hamilton路径, 然后回边要尽量往前, 所以双指针处理一下. Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 1e2 + 7;int dp[MAX_N][MAX_N];int T, n;vector&lt;int&gt; hamilton(int l, int r) { if (l == r) return {l}; int mid = (l + r) &gt;&gt; 1; vector&lt;int&gt; a = hamilton(l, mid); vector&lt;int&gt; b = hamilton(mid + 1, r); vector&lt;int&gt; res; int i = 0, j = 0, tmp; while (i &lt; a.size() &amp;&amp; j &lt; b.size()) { printf(\"1 %d %d\\n\", a[i], b[j]); fflush(stdout); scanf(\"%d\", &amp;tmp); if (tmp) { res.push_back(a[i++]); } else { res.push_back(b[j++]); } } while (i &lt; a.size()) res.push_back(a[i++]); while (j &lt; b.size()) res.push_back(b[j++]); return res;}void work(int n) { vector&lt;int&gt; h = hamilton(0, n - 1); int p = n - 1, tmp; memset(dp, 0, sizeof dp); for (int i = 0; i &lt; n; ++i) dp[i][i] = 1; for (int i = n - 1; i; --i) { if (i) dp[h[i - 1]][h[i]] = 1; if (p &gt;= i) p = i - 1; while (p &gt;= 0) { printf(\"2 %d %d \", h[i], p + 1); for (int j = 0; j &lt;= p; ++j) printf(\"%d \", h[j]); puts(\"\"); fflush(stdout); scanf(\"%d\", &amp;tmp); if (tmp) { dp[h[i]][h[p--]] = 1; } else { break; } } } for (int k = 0; k &lt; n; ++k) { for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; n; ++j) { dp[i][j] |= dp[i][k] &amp; dp[k][j]; } } } puts(\"3\"); for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt; n; ++j) { printf(\"%d\", dp[i][j]); } puts(\"\"); } fflush(stdout); scanf(\"%d\", &amp;tmp);}int main() { scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d\", &amp;n); work(n); } return 0;}","link":"/CF/cf-round-716-div-2/"},{"title":"我们终于可以见面了: 迷宫的十字路口","text":"认真看完以前柯南的剧场版，发现编剧是真的细啊。感觉都是天才级别的，情商也非常的高。 我觉得这部电影本格色彩还是很浓厚的，而且除了较为平淡的推理外还有一些扣人心弦的场景，并且融入大量的日本文化元素，可以说真的是引人入胜。 故事有两条线索，一条边是主线：连环杀人案和佛像的事还有就是关于服部的初恋情人。主线也就是杀人案的推进非常合理，但也较为神秘，观众开始也容易云里雾里，为什么要追杀平次？但这些疑虑随着电影的放映竟然全都都完美地和其他事情联系上了。推理部分也十分精彩，主要围绕一个宝藏的解谜游戏展开，利用了日本文化一些元素还有街道名从而获取了宝藏位置。而这些又恰好和平次初恋情人唱的歌谣完美联系在一起，可以说是非常用心了。电影本身非常日本，樱花、歌舞伎、盗贼集团任务代号取自日本历史中弁庆和义经，出现很多相关的名胜古迹，可以说这种独到的美很令人享受。 另外一条线就是平次初恋，虽然一般大家都会猜到就是和叶，因为青山真的是青梅竹马控，但是电影中一直都好像在暗示另一位歌舞伎才是他的初恋，这种设计还是恰到好处的，让人觉得很顺畅。而且最后平次是在很偶然的情况下发现的，原来自己日夜想要找的初恋情人一直就在自己眼前，那种感觉，应该很不一般吧。 “我们终于可以见面了。” 而和叶却以为他真的见到初恋情人了，十分关切地问是谁。 “我这一辈子都不会告诉你的，哦，可能1500年以后会。” 略带伤感，又带有欣慰，但确实是这样浪漫与美好。 最后小兰说啊， “其实 我并不讨厌等待的感觉， 因为 你等的时间如果越久， 见面的时候， 就越开心啊！” 很唯美的画面。","link":"/Film/%E6%88%91%E4%BB%AC%E7%BB%88%E4%BA%8E%E5%8F%AF%E4%BB%A5%E8%A7%81%E9%9D%A2%E4%BA%86-%E8%BF%B7%E5%AE%AB%E7%9A%84%E5%8D%81%E5%AD%97%E8%B7%AF%E5%8F%A3/"},{"title":"CF round#658 D","text":"D. Unmerge solution 可以发现如果一个数后面连续的比它小的数必须&quot;连成一块&quot;地出现在 $a$ 或者 $b$ 序列中, 这是因为如果不是这样的话. 那么考虑这个数 $p_i$, 若他前面的数已经由两个序列生成, 而其后面的比它小的第一个不载当前序列(不妨记为 $a$)中的数字 $p_j$ , 则必须在 $b$ 中, 但是注意 $b$ 当前元素必为 $p_j$, 若不是, 则为 $p_j$ 后面数字, 但是在同一序列中后面的数字不会比前面的数字早在生成的序列中出现, 会产矛盾. 故 $b$ 最前的元素为 $p_j$, 但是下一次 $merge$ 则会先弹出 $p_j(p_j&lt;p_i)$, 那么又再次矛盾. 所以把每个连续的块看成一个物品, 其重量为块的长度. 然后利用 $0-1$ 背包判断是不是可行解即可. (就是要选择若干段使得长度和为 $n$, 然后按照出现的前后顺序排列即可.) 复杂度: $O(\\sum n^2)$. Code 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 2e3 + 7;int p[MAX_N &lt;&lt; 1], w[MAX_N &lt;&lt; 1]; bool dp[MAX_N];int T, n, cnt; int main() { scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i) scanf(\"%d\", p + i), w[i] = 0; cnt = 0; for (int i = 1; i &lt;= (n &lt;&lt; 1); ) { int a = p[i]; ++cnt; while (i &lt;= (n &lt;&lt; 1) &amp;&amp; p[i] &lt;= a) { ++w[cnt]; ++i; } } for (int i = 0; i &lt;= n; ++i) dp[i] = false; dp[0] = true; for (int i = 1; i &lt;= cnt; ++i) { for (int v = n; v &gt;= w[i]; --v) { dp[v] = dp[v] | dp[v - w[i]]; } } if (dp[n]) { puts(\"YES\"); } else { puts(\"NO\"); } } return 0;}","link":"/DP/cf-round-658-d/"},{"title":"圆内整点, 本原勾股数, 勾股数","text":"首先学习3b1b的视频: 隐藏在素数规律中的 $\\pi$ 由此得到半径为 $\\sqrt{n}$ 的圆上整点个数为: $$ \\chi * u{(n)}=\\sum_{d\\mid n}\\chi(d) $$ 由此可以预处理素数在 $O(\\frac{n}{\\log n})$ 时间内计算圆上整点个数. 圆内整点 即计算: $$ \\sum_{i=1}^{n^2}\\sum_{d\\mid i} \\chi(d) $$ 交换次序得到: $$ \\sum_{d=1}^{n^2}\\chi(d)\\lfloor n^2/d\\rfloor $$ 数论分块: $O(n)$. 暂时还不知道可以怎么算. 本原勾股数 见上篇博客: PE#540 勾股数 和圆内整点公式类似, 但要注意&quot;斜边&quot;应该是整数, 所以枚举的半径应该是整数: $$ \\sum_{i=1}^{n}\\sum_{d\\mid i^2}\\chi(d) $$ 注意到 $\\chi$ 完全积性, 所以若 $i=p_1^{\\alpha_1}p_2^{\\alpha_2}\\ldots p_k^{\\alpha_k}$, 则: $$ \\sum_{d\\mid i} \\chi(d)=(1+\\chi(p_1)+\\ldots+\\chi^{\\alpha_1}(p_1))(1+\\chi(p_2)+\\ldots)\\ldots(1+\\chi(p_k)+\\ldots) $$ 而对于 $p=4k+1$, $\\chi(p)=1$, $p=4k-1$ 为 $-1$, $p=2$ 为 $0$. 也就是上式中 $p_i=4k+1$ 的情况那项因数为 $\\alpha_i+1$, $p_i=4k-1$ 时根据 $\\alpha_i$ 的奇偶性判断, 若为奇数则为 $0$, 偶数则为 $1$, $p_i=2$ 无论如何贡献都是 $1$. 而平方后, 所有幂次全部变为偶数, 那么原本 $p=4k-1$ 的情况对答案贡献一定为 $1$ 所以和 $2$ 的情况是一样的, 所以只需要计算 $p=4k+1$ 的情况, 容易发现这时候贡献为 $(2\\alpha+1)$, 所以可以在线性筛的过程中预处理出来. 时间复杂度: $O(n)$, min_25 筛应该可以做到亚线性, 还没试过.","link":"/%E6%95%B0%E8%AE%BA/%E5%9C%86%E5%86%85%E6%95%B4%E7%82%B9-%E6%9C%AC%E5%8E%9F%E5%8B%BE%E8%82%A1%E6%95%B0-%E5%8B%BE%E8%82%A1%E6%95%B0/"},{"title":"PE#540","text":"Counting primitive Pythagorean triples Solution 想了一个很爬的 $O(\\sqrt{n}\\log n)$ 的做法. 注意到本原勾股数的通解: 就是要找 $u, v$ 满足 $(u, v)=1$ 平方和小于等于 $n$ 且 $u, v$ 不同奇偶的组数. 所以就是计算: $$ \\sum_{u=1}^{\\sqrt{n}}\\sum_{v=1}^{\\min{(u, \\sqrt{n-u^2})}}[(u,v)=1{and} 2\\nmid (u-v)] $$ 依据 $v$ 的上限分成两部分处理: $u, \\sqrt{n-u^2}$. 对于第一种情况: 类似于求解欧拉函数, 但是奇数情况有所不同, 就是与其互素且是奇数的不能计算在内. 也就是计算偶数且与其互素的, 也就是求 $u/2$ 以下的与其互素的数个数, 根据: $(i,u)=(u-i,u)$ 知这部分答案为: $\\varphi(u)/2$. 对于第二部分: 记 $k=\\sqrt{n-u^2}$, $$ \\begin{align*} \\sum_{i=1}^{k}[(i,u)=1]&=\\sum_{i=1}^{k}\\sum_{t\\mid i\\\\ t\\mid u}\\mu{(t)}\\\\ &=\\sum_{t\\mid u}\\sum_{i=1}^{k}[t\\mid i]\\\\ &=\\sum_{t\\mid u}\\mu(t)\\lfloor \\frac{k}{t}\\rfloor \\end{align*} $$ 对于 $u$ 为奇数的情况, 式子中的 $k$ 应当为 $k/2$, 所以预处理一下卷积即可. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 6e7 + 7;int pri[MAX_N], phi[MAX_N], f[MAX_N], mu[MAX_N];int n, cnt, ans;void Euler(int n) { phi[1] = mu[1] = 1; for (int i = 2; i &lt;= n; ++i) { if (!phi[i]) { pri[++cnt] = i; phi[i] = i - 1; mu[i] = -1; } for (int j = 1; j &lt;= cnt &amp;&amp; 1ll * i * pri[j] &lt;= 1ll * n; ++j) { if (i % pri[j] == 0) { phi[i * pri[j]] = phi[i] * pri[j]; mu[i * pri[j]] = 0; break; } phi[i * pri[j]] = phi[i] * (pri[j] - 1); mu[i * pri[j]] = -mu[i]; } }}signed main() { scanf(\"%lld\", &amp;n); Euler(6e7); int sqr = (int)sqrt(n); for (int u = 1; u &lt;= sqr; ++u) { for (int i = u; i &lt;= sqr; i += u) { int k = sqrt(n - i * i); if (i &amp; 1) { f[i] += k / 2 / u * mu[u]; } else { f[i] += k / u * mu[u]; } } } int i; for (i = 2; i * i &lt;= n / 2; ++i) { if (i &amp; 1) { ans += phi[i] / 2; } else { ans += phi[i]; } } for ( ; i * i &lt;= n; ++i) { ans += f[i]; } printf(\"%lld\\n\", ans); return 0;}","link":"/PE/pe-540/"},{"title":"Educational Codeforces Round#107 E","text":"E. Colorings and Dominoes Solution 如果考虑某个骨牌对答案的贡献, 那么也就是其他的格子随便填的种数. 但是有可能会重复计算, 比如 “ooo”, 前两个作为骨牌放置和后面两个会有一种情况是重复计算贡献的, 因为可能有多种放骨牌方法, 但是价值却是一样的. 发现只有连续的行或列的格子会有相互影响, 考虑一个长列的&quot;价值&quot;, 然后其他位置随便填, 这时候贡献为: 当前列的价值 $\\times 2^{w-cnt}$, $cnt$ 为当前列长度. 复杂度: $O(nm\\log M)$. 递推类似斐波那契数列(相邻格子不相同方案数)的递推, 可以这样考虑: 用 $f[i]$ 表示考虑 $i$ 个格子的方案数. 那么当前格子有两种情况: ‘*’: 方案数为 $f[i-1]$; ‘o’: 考虑第 $i-1$ 的位置: ‘*’: $f[i-2]$; ‘o’: 强制连锁后面两个作为骨牌放置处, 最优价值肯定能由此构造, 故由 $f[i-2]$ 转移, 且要加上前面随便填的方案数: $2^{i-2}$. 即: $$ f[i]=f[i-1]+2f[i-2]+2^{i-2} $$ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MOD = 998244353;const int MAX_N = 3e5 + 7;char mp[MAX_N];int dp[MAX_N];bool vis[MAX_N];int n, m, w, ans;int f_pow(int base, int b, int mod = MOD) { int res = 1; while (b) { if (b &amp; 1) res = res * base % mod; base = base * base % mod; b &gt;&gt;= 1; } return res;}void init(int n) { dp[1] = dp[0] = 0; for (int i = 2; i &lt;= n; ++i) { dp[i] = (dp[i - 1] + (dp[i - 2] &lt;&lt; 1) + f_pow(2, i - 2)) % MOD; }}signed main() { scanf(\"%lld%lld\", &amp;n, &amp;m); init(max(n, m)); for (int i = 1; i &lt;= n; ++i) { scanf(\"%s\", mp + 1 + (i - 1) * m); for (int j = 1; j &lt;= m; ++j) { if (mp[(i - 1) * m + j] == 'o') ++w; } } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) { if (!vis[(i - 1) * m + j] &amp;&amp; mp[(i - 1) * m + j] == 'o') { int cnt = 0; while (j &lt;= m &amp;&amp; !vis[(i - 1) * m + j] &amp;&amp; mp[(i - 1) * m + j] == 'o') { vis[(i - 1) * m + j] = true; ++cnt, ++j; } ans = (ans + dp[cnt] * f_pow(2, w - cnt) % MOD) % MOD; } } } memset(vis, 0, sizeof vis); for (int j = 1; j &lt;= m; ++j) { for (int i = 1; i &lt;= n; ++i) { if (!vis[(i - 1) * m + j] &amp;&amp; mp[(i - 1) * m + j] == 'o') { int cnt = 0; while (i &lt;= n &amp;&amp; !vis[(i - 1) * m + j] &amp;&amp; mp[(i - 1) * m + j] == 'o') { vis[(i - 1) * m + j] = true; ++cnt, ++i; } ans = (ans + dp[cnt] * f_pow(2, w - cnt) % MOD) % MOD; } } } printf(\"%lld\\n\", ans); return 0;} END zcxnb!","link":"/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/educational-codeforces-round-107-e/"},{"title":"Divide by Zero 2021 and CF Round #714(Div. 2)","text":"Divide by Zero 2021 and CF Round #714(Div. 2) A. Array and Peaks 可行条件是 $2k+1\\leq n$, 随便乱构造即可. B. AND Sequences 可以发现只要满足: $$ a_0=a_n=a_1\\& a_2\\& \\ldots\\& a_n $$ 即可. C. Add One 简单递推, 用 $f[i][k]$ 表示 $i$ 操作 $k$ 次后的长度, 有: $$ f[i][k]=f[1][k-10+i]+f[0][k-10+i] $$ 预处理之后 $O(\\log n)$ 回答即可. D. GCD and MST Solution 从小到大枚举公约数, 将以其为中心的所有可以连边的点检查和原来的 $p$ 的大小关系, 可以发现这些点之间不会再连新的边, 所以打上标记, $O(n)$ 扫描一遍即可. 复杂度: $O(n\\log n)$. Code 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 2e5 + 7;int a[MAX_N], ord[MAX_N];bool vis[MAX_N];int T, n, p, ans;bool cmp(const int &amp;x, const int &amp;y) { return a[x] &lt; a[y];}signed main() { scanf(\"%lld\", &amp;T); while (T--) { scanf(\"%lld%lld\", &amp;n, &amp;p); ans = p * (n - 1); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i), ord[i] = i, vis[i] = false; sort(ord + 1, ord + 1 + n, cmp); for (int i = 1; i &lt;= n; ++i) { int now = ord[i]; if (vis[now]) continue; if (a[now] &gt;= p) break; for (int j = now + 1; j &lt;= n &amp;&amp; a[j] % a[now] == 0; ++j) { ans += a[now] - p; if (vis[j]) break; vis[j] = true; } for (int j = now - 1; j &gt; 0 &amp;&amp; a[j] % a[now] == 0; --j) { ans += a[now] - p; if (vis[j]) break; vis[j] = true; } } printf(\"%lld\\n\", ans); } return 0;} E. Cost Equilibrium 可以发现到sink点或者source点多于一个时要全部放在一边, 然后简单讨论一下, 利用组合数学知识进行统计. F. Swapping Problem Solution 可以发现, 会对答案产生贡献的两个点一定是两个 $a$ 在中间或者两个 $b$ 在中间, 且贡献为重叠部分两倍的相反数. 也就说一个是 $a&lt;b$, 另一个是 $a&gt;b$, 最大化重叠部分. 故分类后进行排序, 可以发现排序后的数组应该满足 $a,b$ 均递增, 否则可以舍去. 所以可以直接对两种情况二分查找, 或者利用栈处理. 复杂度: $O(n\\log n)$. Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;#define int long long#define INF (1e15 + 7)#define pii pair&lt;int, int&gt;using namespace std;struct Node { int x, y; Node(int _x = 0, int _y = 0) : x(_x), y(_y) {} bool operator&lt;(const Node &amp;u)const { if (x &lt; u.x) return true; if (x &gt; u.x) return false; return y &gt; u.y; }};const int MAX_N = 2e5 + 7;Node in[MAX_N], de[MAX_N];vector&lt;pii&gt; ab, ba;int a[MAX_N], b[MAX_N];int n, mx, dis;int low_bound(vector&lt;pii&gt; &amp;s, int x) { if (!s.size() || s.begin()-&gt;first &gt; x) return -1; int l = 0, r = s.size() - 1; while (l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; if (s[mid].first &lt;= x) l = mid; else r = mid - 1; } return s[l].second;} signed main() { // freopen(\"in.txt\", \"r\", stdin); scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", b + i); int n1 = 0, n2 = 0; for (int i = 1; i &lt;= n; ++i) { if (a[i] &lt; b[i]) in[++n1] = Node(a[i], b[i]); else if (a[i] &gt; b[i]) de[++n2] = Node(b[i], a[i]); dis += abs(a[i] - b[i]); } sort(in + 1, in + 1 + n1); sort(de + 1, de + 1 + n2); for (int i = 1; i &lt;= n1; ++i) { if (!ab.size() || in[i].y &gt; (ab.end() - 1)-&gt;second) { ab.push_back(pii(in[i].x, in[i].y)); } } for (int i = 1; i &lt;= n2; ++i) { if (!ba.size() || de[i].y &gt; (ba.end() - 1)-&gt;second) { ba.push_back(pii(de[i].x, de[i].y)); } } for (int i = 0; i &lt; ab.size(); ++i) { int y = low_bound(ba, ab[i].first); if (~y) mx = max(mx, min(y, ab[i].second) - ab[i].first); } for (int i = 0; i &lt; ba.size(); ++i) { int y = low_bound(ab, ba[i].first); if (~y) mx = max(mx, min(y, ba[i].second) - ba[i].first); } printf(\"%lld\\n\", dis - mx * 2); return 0;} END 写的函数传了一个vector形参直接不停TLE… 我到底还得爬多久…","link":"/CF/divide-by-zero-2021-and-cf-round-714-div-2/"},{"title":"AGC#053 A","text":"A - &gt;&lt; again 这么爬的我是不敢开AGC的, 然而昨天两个队友都在打? 赶紧看看他们做的啥题, 然后想了下A继续爬了… 因为此前做过一个问法类似的题, 不过是要分成两个序列, 然后一个升序/降序, 当时好像是推个什么不等式就好了. Solution 很明显看出答案具有单调性, 很大可能就是二分答案了. 发现原来的序列必定满足 $S$ 的要求, 现在考虑要分成 $k$ 组, 那么每组平均分配: $$ \\frac{a_1}{k},\\frac{a_2}{k},\\ldots,\\frac{a_n}{k} $$ 如果说这些数都是整数那么 $k$ 组显然是可行的. 如果不是整数呢? 那么为了获得&quot;整数&quot;, 可以利用带余数除法: $a_i=q_ik+r_i$. 取其中相邻一对: $q_i+r_i/k$ 和 $q_{i+1}+r_{i+1}/k$, 并且假定其大小关系为 $&lt;$. 那么就有三种情况: $q_i&gt;q_{i+1}$, 那么由于 $q_i+ri/k\\geq q_i\\geq q_{i+1}+1&gt;q_{i+1}+{r_{i+1}}/k$, 得出矛盾, 这种情况根本不可能出现; $q_i=q_{i+1}$, 那么有 $r_i&lt;r_{i+1}$, 但是注意需要 $k$ 组数全部满足 $&lt;$ 的条件, 而这时由于最终 $i$ 上的数 $a_i’$ 肯定比 $a_{i+1}’$ 小, 也就是 $a_i’\\leq a_{i+1}’-1$, 故得出 $a_i\\leq a_{i+1}-k$, 而这与 $q_i=q_{i+1} $ 矛盾, 所以若出现这种情况, 必不可能构造出解; $q_i&lt;q_{i+1}$, 再分两种情况: $q_i=q_{i+1}-1$, 那么如果某个 $q_i$ 加上了 $1$, 相应的 $q_{i+1}$ 也必须加 $1$, 而这时候候选的只有最多 $r_i,r_{i+1}$ 个 $1$, 所以如果 $r_{i}&gt;r_{i+1}$ 则无解; $q_{i}&lt;q_{i+1}-1$, 可以发现将前 $r_i,r_{i+1}$ 个数加 $1$, 是合法的构造. 更一般的, 当排除上述所有非法情况利用此方法容易发现是合法的全局构造. $O(N\\log(A_{max}))$, 感觉数据还可以大很多? Code 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 1e2 + 7;char s[MAX_N];int a[MAX_N], q[MAX_N], r[MAX_N];int n;bool chk(int k) { for (int i = 0; i &lt;= n; ++i) q[i] = a[i] / k, r[i] = a[i] % k; for (int i = 0; i &lt; n; ++i) { if (q[i] == q[i + 1]) return false; if (s[i] == '&lt;') { if (q[i] + 1 == q[i + 1] &amp;&amp; r[i] &gt; r[i + 1]) return false; } else { if (q[i] - 1 == q[i + 1] &amp;&amp; r[i] &lt; r[i + 1]) return false; } } return true;}int main() { scanf(\"%d\", &amp;n); scanf(\"%s\", s); for (int i = 0; i &lt;= n; ++i) scanf(\"%d\", a + i); int k = 1, rt = 10000; while (k &lt; rt) { int mid = (k + rt + 1) &gt;&gt; 1; if (chk(mid)) k = mid; else rt = mid - 1; } printf(\"%d\\n\", k); for (int i = 0; i &lt;= n; ++i) q[i] = a[i] / k, r[i] = a[i] % k; for (int i = 1; i &lt;= k; ++i) { for (int j = 0; j &lt;= n; ++j) { if (i &lt;= r[j]) printf(\"%d \", q[j] + 1); else printf(\"%d \", q[j]); } puts(\"\"); } return 0;} End 看了下官方题解, 发现 $k$ 不用二分也能找出来, 构造方法则是一样的.","link":"/Atcoder/agc-053-a/"},{"title":"爬","text":"卡签到… 看错题… 连约数是 $O(log)$ 的都没想到… 想了两个 dp 复杂度全不对… 有谁比我更能爬?","link":"/uncategorized/%E7%88%AC/"},{"title":"202012CSP认证#4. 食材运输","text":"我太爬了… 一开始写个 $70$ 分做法都能把数组下标常量放错位置… 后面用真做法又是一边边界搞错… 一边连状态转移都能想复杂然后写错… Solution 首先对于 $k=m$ 的情况, 也就是运输车之间互不干扰, 只要对于每一种情况求出最小花费的时间, 然后总的再取一个大的时间. 计算最小的时间: 对于每种食材, 可以发现其路径总是从某一个结点开始然后&quot;转一圈&quot;但是不需要再返回. 于是可以枚举每个点作为开始的结点(根节点), 然后利用树形dp获得以该节点为起点的花费, 然后对每个点取最小值. 用 $dp[u]$ 表示运输车当前在 $u$ 结点, 处理这棵子树需要花费的时间. 贪心地去做, 应该把带权深度最深的结点放到最后一个计算, 因为这个点计算后就没有必要再回到 $u$ 了.(这里和ccpc秦皇岛那个k有点类似). 所以复杂度是 $O(n)$ 的, 那么总的复杂度就是 $O(n^2k)$. 可以过 $70%$, 但是我不知道我哪里又爬了… 获得了 $65$… 很容易想到这应该是一道状态dp的题目, 考虑状态 $f[i][j][S]$ 表示在前面 $i$ 个结点中, 选取了 $j$ 个结点作为检查点, 并且覆盖了 $k$ 种食材的集合 $S$ 的最小时间代价. 那么如果添加一个新的结点 $i + 1$, 就考虑要不要作为新的检查点, 若不用, 就直接由 $f[i][j][S]$ 转移; 否则应该考虑 $i+1$ 去覆盖另一个子集, 然后将其与当前子集并起来再更新. 这样转移的复杂度是 $O(2^k)$ 的, 会 TLE. 但是可以发现, 如果第 $(i+1)$ 个点决定覆盖某一种食材, 那么那些花费时间比这个时间要小的食材也都会被覆盖, 因为在一段时间内允许并行. 所以实际上转移的子集只有 $O(k)$ 个. 时间复杂度: $O(nm2^{k}k)$. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;#define int long long#define INF (1e14 + 7)using namespace std;struct Edge{ int to, nxt, w;};const int MAX_N = 1e2 + 7;const int MAX_K = 17;const int MAX_S = (1 &lt;&lt; 10) + 7;Edge e[MAX_N &lt;&lt; 1];int in[MAX_N][MAX_K], dp[MAX_N], head[MAX_N], mh[MAX_N], dep[MAX_N], son[MAX_N], ext[MAX_N], st[MAX_N][MAX_K], ti[MAX_N][MAX_K], f[MAX_N][MAX_K][MAX_S];int cnt, now, n, m, k, ans;void add(int u, int v, int w) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; e[cnt].w = w;}void dfs(int u, int fa) { ext[u] = in[u][now]; mh[u] = ext[u] ? dep[u] : 0; son[u] = 0; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (v == fa) continue; dep[v] = dep[u] + e[i].w; dfs(v, u); ext[u] = ext[u] | ext[v]; mh[u] = max(mh[u], mh[v]); if (ext[v] &amp;&amp; mh[son[u]] &lt; mh[v]) son[u] = v; }}void tree_dp(int u, int fa) { int cost = 0, costs; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (v == son[u]) costs = e[i].w; if (v == fa || v == son[u] || (!ext[v])) continue; tree_dp(v, u); dp[u] += cost + dp[v] + e[i].w; cost = mh[v] - dep[u]; } if (son[u]) tree_dp(son[u], u), dp[u] += cost + costs + dp[son[u]];}signed main() { scanf(\"%lld%lld%lld\", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= k; ++j) { scanf(\"%lld\", &amp;in[i][j]); } } for (int i = 1; i &lt; n; ++i) { int u, v, w; scanf(\"%lld%lld%lld\", &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= k; ++j) { now = j; memset(dp, 0, sizeof dp); dep[i] = 0; dfs(i, -1); tree_dp(i, -1); ti[i][j] = dp[i]; } for (int j = 1; j &lt;= k; ++j) { for (int t = 1; t &lt;= k; ++t) { if (ti[i][t] &lt;= ti[i][j]) st[i][j] |= 1 &lt;&lt; (t - 1); } } } for (int i = 0; i &lt;= n; ++i) { for (int j = 0; j &lt;= m; ++j) { for (int s = 0; s &lt; (1 &lt;&lt; k); ++s) { f[i][j][s] = INF; } } } for (int i = 0; i &lt;= m; ++i) f[0][i][0] = 0; for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt;= m; ++j) { for (int s = 0; s &lt; (1 &lt;&lt; k); ++s) { for (int t = 1; t &lt;= k; ++t) { f[i + 1][j + 1][s | st[i + 1][t]] = min(max(f[i][j][s], ti[i + 1][t]), f[i + 1][j + 1][s | st[i + 1][t]]); f[i + 1][j][s] = min(f[i + 1][j][s], f[i][j][s]); } } } } printf(\"%lld\\n\", f[n][m][(1 &lt;&lt; k) - 1]); return 0;}","link":"/DP/202012csp%E8%AE%A4%E8%AF%81-4-%E9%A3%9F%E6%9D%90%E8%BF%90%E8%BE%93/"},{"title":"卷积: 变换与反演","text":"… 数论函数 在全体正整数(或全体整数)上定义的函数称作数论函数. 常见的数论函数 常数函数 $u(n)=1, n\\geq 1$ 恒等函数 $e_k(n)=n^k, n\\geq 1$ 单位函数 $I(n)=[n=1]$ $n$ 的因数个数除数函数: $d(n)=\\sum_{d\\mid n}1$ $n$ 的全部素因子个数: $$ \\Omega(n)=\\alpha_1+\\alpha_2+\\ldots+\\alpha_k,n=p_1^{\\alpha_1}p_2^{\\alpha_2}\\ldots p_{k}^{\\alpha_k} $$ $n$ 的不同素因子个数: $$ \\omega{(n)}=k, n =p_1^{\\alpha_1}p_2^{\\alpha_2}\\ldots p_{k}^{\\alpha_k} $$ $n$ 的正除数的幂和函数 $\\sigma_\\lambda(n)$: $$ \\sigma_\\lambda(n)=\\sum_{d\\mid n}d^{\\lambda} $$ 欧拉函数: $$ \\varphi(n)=\\sum_{d=1}^n [gcd(d, n)=1] $$ 莫比乌斯($M\\ddot{o}bius$)函数: $$ \\mu(n)= \\begin{cases} 1, n=1\\\\ (-1)^s, n = p_1p_2\\ldots p_s\\\\ 0, others\\\\ \\end{cases} $$ $Liouville$ 函数: $$ \\lambda(n)=(-1)^{\\Omega(n)} $$ 卷积 定义运算 $*$ : $$ (f*g)(n)=\\sum_{d\\mid n}f(d)g(\\frac{n}{d}) $$ 称运算 $*$ 为卷积运算或者 Dirichlet 乘积. 代数性质 简单利用配对的思想即可证明 $*$ 具有交换律. 可以证明: $f*g*h=\\sum_{abc=n}f(a)g(b)h(c)=f*(g*h)$ . 故其具有结合律. 另外容易发现有单位元 $I$ 使得: $$ f*I=I*f=f $$ 莫比乌斯变换 对于含有一个特殊函数常数函数 $u$ 的卷积: $$ F(n)=(f*u)(n)=\\sum_{d\\mid n}f(d) $$ 称 $F$ 为 $f$ 的莫比乌斯变换. 例如 $\\mu$ 的莫比乌斯变换为: $$ \\sum_{d\\mid n}\\mu(d)= \\begin{cases} 1, n=1\\\\ 0, n>1 \\end{cases} $$ 证明可以利用其只有单素数相乘的因子进行简单讨论得到. 特别的, $d(n)$ 是 $u(n)$ 的莫比乌斯变换. 另外可以看到: $$ I=\\mu * u $$ 也就是说 $u$ 是 $\\mu$ 的逆元. 事实上可以证明, 所有数论函数在所有数论函数构成的集合 $G$ 中都能找到其逆元. 也就是 $(G, *)$ 实际上构成了一个 Abel 群. 由上一个等式, 我们可以引出另一种变换, 也就是莫比乌斯反变换, 或称为莫比乌斯反演: $$ F=f*u\\Rightarrow f=F*\\mu $$ 利用前文所述性质即可简单证明. 我们知道: $$ n=\\sum_{d\\mid n}\\varphi(d) $$ 故 $e$ 是 $\\varphi$ 的莫比乌斯变换, 换言之: $\\varphi = e*\\mu$. 积性函数 若数论函数满足: $$ f(mn)=f(m)f(n),(m, n)=1 $$ 称 $f$ 为积性函数或者可乘函数. 特别的, 若可以没有 $(m,n)=1$ 这一条件则成为完全积性函数. 性质 $f(1)=1$. $f(n)=f(p_1^{\\alpha_1})f(p_2^{\\alpha_2})\\ldots f(p_{s}^{\\alpha_s})$. $f$ 的莫比乌斯变换仍为积性函数. 若 $g$ 也为积性函数, 则 $f*g$ 也为积性函数. 积性函数逆元亦为积性函数. 常见的 $\\mu,d,\\varphi$ 都是积性函数. 注意: 积性函数和加性函数很多都能利用线性筛或者其他筛法在线性或者更优时间内计算前缀和. 这为解决一些看似困难的问题提供的新的方法. 贝尔级数 贝尔级数可以帮我们计算各种乱七八糟的积性函数卷起来是什么函数. 定义数论函数 $f$ 在模素数 $p$ 意义下的贝尔级数: $$ f_p(x)=\\sum_{i=0}^{\\infty}f(p^i)x^i $$ 特别的, 对于完全积性函数 $f$, 有: $$ \\begin{align*} f_p(x)&=\\sum_{i=0}^{\\infty}f(p^i)x^i\\\\ &=\\sum_{i=0}^{\\infty}f^i(p)x^i\\\\ &=\\frac{1}{1-f(p)x} \\end{align*} $$ 注意此处我们不考虑其级数收敛性而假设其进行计算, 是为了利用下面的结论而帮助我们进行问题的分析和简化. 这让我们关注到了更本质的东西. 则有: $$ (f*g)_p=f_p\\times g_p $$ 就像 $Laplace$ 变换一样, 可以把卷积变成多项式的乘法, 对于某些问题的分析研究是有利的. 证明: 由前面的性质2可以知道只需要证明 $n=p^k$ 上述等式始终成立即可. $$ \\begin{align*} (f*g)_p(x)&=\\sum_{i=0}^{\\infty}\\left(\\sum_{j=0}^{i}f(p^i)g(p^{i-j})\\right)x^i\\\\ &=\\sum_{i=0}^{\\infty}f(p^i)x^i\\sum_{j=0}^{\\infty}f(p^j)x^j\\\\ &=(f_p\\times g_p)(x) \\end{align*} $$ 常见函数的贝尔级数 $\\mu_p(x)=1-x$ $e_p(x)=\\frac{1}{1-px}$ $\\varphi_p(x)=(\\mu_p\\times e_p)(x)\\frac{1-x}{1-px}$ $u_p(x)=\\frac{1}{1-x}$ 由 $\\mu_p\\times u_p=1$ 可以发现, 互为逆的两个数论函数的贝尔级数相乘恰好是 $1$. 莫比乌斯反演例题 其实这些叫做反演的题目没看出来用到了什么反演… 我只觉得用到了数论函数的一些性质. 莫比乌斯反演主要在对式子进行化简, 已达到类似如下的形式: $$ \\sum_{i=1}^n F(n/i)S(i) $$ 前者是与 $n/i$ 相关的函数, 可以利用数论分块进行处理, 后者一般是一个积性函数(或者加性), 因为积性函数往往可以通过线性时间预处理前缀和或者利用特殊方法(杜教筛, min_25筛)来快速计算前缀和. [HAOI2011]Problem b LCMSUM [国家集训队]Crash的数字表格 / JZPTAB 此题 OI wiki 上给的方法是用数论分块套数论分块. 其实可以只用一次. 我最后推出的式子是: $$ \\sum_{t=1}^{n}S(\\frac{n}{t})S(\\frac{m}{t})\\sum_{u\\mid t}u^2\\mu(u)\\frac{t}{u} $$ 其中 $S(n)=1+2+\\ldots+n$. 后面是一个卷积, 并且两个函数都是积性函数, 最后卷出来也是积性函数, 然后利用贝尔级数容易得到线性筛预处理出前缀和的方法. 其贝尔级数为: $$ 1+(p-p^2)x+(p^2-p^3)x^2+\\ldots $$ 所以素数就是 $p-p^2$. 如果是有一个素因子重复, 只需要乘 $p$ 就行了. 但是复杂度不变就是了. 「SDOI2015」约数个数和 简单的数学题 A Very Easy Math Problem 前面题目都是 OI wiki 上的例题, 就不多说了, 自己推推式子. 这题稍微化简一下得到: $$ \\sum_{t=1}^nS(\\frac{n}{t})t^{kx}\\sum_{u\\mid t}{\\mu(u)\\left(\\mu^2(\\frac{t}{u})\\cdot \\frac{t}{u}\\right)} $$ 其中 $S(n)=(\\sum_{i=1}^n i^k)^x$. 后面显然又是两个积性函数相乘, 其贝尔级数为: $$ f_p(x)=1+(p-1)x-px^2 $$ 当然因为这题要快速幂, 所以不做这个优化也无所谓, 直接 $O(n\\log n)$ 预处理卷积就行了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MOD = 1e9 + 7;const int MAX_N = 2e5 + 7;int pri[MAX_N], mu[MAX_N], s[MAX_N];bool vis[MAX_N];int T, k, x, n, cnt, ans;void Euler(int n) { mu[1] = 1; for (int i = 2; i &lt;= n; ++i) { if (!vis[i]) { pri[++cnt] = i; mu[i] = -1; } for (int j = 1; j &lt;= cnt &amp;&amp; i * pri[j] &lt;= n; ++j) { vis[i * pri[j]] = true; if (i % pri[j] == 0) { mu[i * pri[j]] = 0; break; } mu[i * pri[j]] = -mu[i]; } }}int f_pow(int base, int b, int mod = MOD) { int res = 1; while (b) { if (b &amp; 1) res = res * base % mod; base = base * base % mod; b &gt;&gt;= 1; } return res;}void init(int n) { Euler(n); for (int i = 1; i &lt;= n; ++i) s[i] = (s[i - 1] + f_pow(i, k)) % MOD; for (int i = 1; i &lt;= n; ++i) s[i] = f_pow(s[i], x); memset(pri, 0, sizeof pri); for (int u = 1; u &lt;= n; ++u) { for (int t = u; t &lt;= n; t += u) { pri[t] = (pri[t] + mu[u] * mu[t / u] * mu[t / u] * t / u) % MOD; } } for (int i = 1; i &lt;= n; ++i) pri[i] = (pri[i] * f_pow(i, (k * x) % (MOD - 1)) % MOD + pri[i - 1]) % MOD;}signed main() { scanf(\"%lld%lld%lld\", &amp;T, &amp;k, &amp;x); init(2e5); while (T--) { scanf(\"%lld\", &amp;n); ans = 0; for (int i = 1, j; i &lt;= n; i = j + 1) { j = n / (n / i); ans = (ans + s[n / i] * (pri[j] - pri[i - 1]) % MOD) % MOD; } printf(\"%lld\\n\", (ans + MOD) % MOD); } return 0;} 参考资料 潘承洞: 《数论基础》, 2012年12月版; OI wiki: 莫比乌斯反演.","link":"/%E6%95%B0%E8%AE%BA/%E5%8D%B7%E7%A7%AF-%E5%8F%98%E6%8D%A2%E4%B8%8E%E5%8F%8D%E6%BC%94/"},{"title":"How to Get Popcount","text":"昨天晚上做 CS: APP 的 data lab 的时候, 在 howManyBits 这个函数的实现上爬了一万年… 很关键一点就是我不懂高效实现 popcount 的方法. 赶紧学习了一下, 发现自己真的需要好好学习… 我太 naive 了… popcount(x) 函数用于计算二进制表示的 $x$ 中有几个非零位(就是有几个 $1$). 很显然的一种方法就是逐位枚举并统计, 那么显然就是 $O(\\omega)$ 的, $\\omega$ 是位数, 比如 int 是 $32$ 位. 由于实际情况中 $1$ 的个数可能很少, 于是有另一种优化的方式. 利用 1x = x &amp; (x - 1); 这个操作会将 $x$ 最后一个 $1$ 清除, 那么只需要做 $popcount(x)$ 次即可. 但是注意到实际情况中可能出现全为 $1$ 的情况, 所以这个算法只做了部分的优化, 最终还是 $O(\\omega)$ 的. 这时候在网上看到一种天才算法: SWAR 算法(建议直接看这篇博客, 写得很清楚). 这个算法的具体实现如下: 12345int swar(uint32_t i) { i = i - ((i &gt;&gt; 1) &amp; 0x55555555); i = (i &amp; 0x33333333) + ((i &gt;&gt; 2) &amp; 0x33333333); return (((i + (i &gt;&gt; 4)) &amp; 0x0F0F0F0F) * 0x01010101) &gt;&gt; 24;} 这个算法基于一个事实: 对于一个只有两位数的二进制数: $(b_0b_1)$, 那么将其右移一位得到 $(0b_0)$, 将两数相减可以发现(令 $T((b_0b_1))=(b_0b_1)-(0b_0)$): $T((00))=(00)=0$, $T((01))=(01)=1$, $T((10))=(01)=1$, $T((11))=(10)=2$. 由此发现: $T((b_0b_1))$ 恰好就是 $(b_0b_1)$ 中 $1$ 的个数! 所以利用这个原理先将从原来的序列中获取&quot;一块块&quot;的 $1$ 的个数: 1x = x - ((x &gt;&gt; 1) &amp; 0x55555555) 也就是将整体移位后并将所有奇数位置为 $0$. (以 $32$ 位的 int 为例, 并且最后一位下标为 $0$) 接下来为了得到所有两位两位数之和, 再继续考虑两两配对的方法: 第一个和第二个数组成的二进制数加上第三个和第四个组成的二进制数, 第五个和第六个… 以此类推. 这么做完之后可以发现现在四位四位组成的二进制数已经恰好是其对应原来 $x$ 的那四位数字上 $1$ 的个数. 那么接着就是四个四个相加, 再八个八个相加, 最后十六个十六个相加得到的数就是我们要的 $popcount(x)$ 的值. 容易看出来这样的复杂度就是 $O(\\log \\omega)$ 的. 但是我们可以看到实际上的 SWAR 算法并不是这样实现的. 他只重复到了四个四个数的相加, 然后这样答案就应当是 $4$ 个 $8$ 位数的和, 这时候利用了乘法溢出后前面的位会被截断的技巧, 也就是 $\\times 0x01010101$. 这样可以使操作数大大减少. SWAR 算法还用到了另一个技巧, 那就是在这种情况下: (i + (i &gt;&gt; 4)) &amp; 0x0f0f0f0f 和 (i &amp; 0x0f0f0f0f) + ((i &gt;&gt; 4) &amp; 0x0f0f0f0f) 是相等的. 要注意与运算对于加法是没有分配律的, 但在这里是对的, 这是因为每个四位数大小实际上意味着原来的数的这四位上 $1$ 的个数. 那么显然是 $\\leq 4$ 的, 那么任意两个四位数相加都不会超过 $8$, 自然没有&quot;溢出&quot;的情况发生, 所以此处用法是正确的. 由此减少了一个 &amp; 的使用. 基于这个想法的其他算法好像也很多, 比如 hacker_popcnt 算法: 12345678int hacker_popcnt(uint32 x) { x -= (x &gt;&gt; 1) &amp; m1; x = (x &amp; m2) + ((x &gt;&gt; 2) &amp; m2); x = (x + (x &gt;&gt; 4)) &amp; m4; x += x &gt;&gt; 8; x += x &gt;&gt; 16; return x &amp; 0x7f;}","link":"/CS-APP/how-to-get-popcount/"},{"title":"2020 CCPC Qinhuangdao K. Kingdom's Power","text":"K. Kingdom’s Power 最近发现很多题目似乎都很类似… 这又是一道当时比赛时爬了半天最后还是不会的题目… solution 首先对于每个需要占领的点, 都有两种方式: 将已经占领过别的点的军队转移到此处; 从根节点重新派遣一支新的军队. 可以发现利用第二种方式是由于已经存在的军队到当前结点的距离小于根节点到当前结点的距离. 并且由此做简单的逻辑推导可以发现: 对于某一个结点的子树, 用于第二种方式的军队最多只会有一支. 并且总是从深度浅的到深度深的, 最后这支军队会到达该树最深处(满足不需要从根节点重新派遣的前提下的最深处). 这也就是贪心的做法. 考虑动态规划: 用 $f[u]$ 表示当前结点 $u$ 有一支军队, 接着要征服其子树需要多少时间. 那么我们将其子树按照最深深度由浅到深排序. 那么每次合并一个子树, 都要考虑是要从上个子树的最深处还是要从根节点的军队派遣一个到节点上, 所以记录上一子树的最深深度(为什么不考虑用于第二种方式的军队到达的最深处?)来更新这个状态的一个初始代价 $cost[v]$. 则有: $$ f[u]=\\sum_{v\\in son(u)}(f[v]+cost[v]) $$ 时间复杂度: $O(n\\log n)$. code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 1e6 + 7;int dp[MAX_N], dep[MAX_N], mh[MAX_N];vector&lt;int&gt; e[MAX_N];int T, n;bool cmp(const int &amp;x, const int &amp;y) { return mh[x] &lt; mh[y];}void add(int u, int v) { e[u].push_back(v);}void dfs(int u) { mh[u] = dep[u]; for (int i = 0; i &lt; e[u].size(); ++i) { int v = e[u][i]; dep[v] = dep[u] + 1; dfs(v); mh[u] = max(mh[u], mh[v]); } sort(e[u].begin(), e[u].end(), cmp);}void tree_dp(int u) { int cost = 1; for (int i = 0; i &lt; e[u].size(); ++i) { int v = e[u][i]; cost = min(cost, dep[v]); tree_dp(v); dp[u] += dp[v] + cost; cost = mh[v] - dep[u] + 1; }}signed main() { scanf(\"%lld\", &amp;T); for (int cas = 1; cas &lt;= T; ++cas) { scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= n; ++i) e[i].clear(), dp[i] = 0; for (int i = 2; i &lt;= n; ++i) { int f; scanf(\"%lld\", &amp;f); add(f, i); } dfs(1); tree_dp(1); printf(\"Case #%lld: %lld\\n\", cas, dp[1]); } return 0;} end 我不能再爬了, 抓紧时间学学 CS: APP 等有用的东西吧… 刚才睡了一觉然后想到, 其实前面的子树不按照大小排序也可以, 只要让深度最深的在最后面就可以了. 那么只要在 $dfs$ 的时候长链剖分即可. 复杂度: $O(n)$ ? 但是好像没快多少? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 1e6 + 7;int dp[MAX_N], dep[MAX_N], mh[MAX_N], son[MAX_N];vector&lt;int&gt; e[MAX_N];int T, n;bool cmp(const int &amp;x, const int &amp;y) { return mh[x] &lt; mh[y];}void add(int u, int v) { e[u].push_back(v);}void dfs(int u) { mh[u] = dep[u]; son[u] = 0; for (int i = 0; i &lt; e[u].size(); ++i) { int v = e[u][i]; dep[v] = dep[u] + 1; dfs(v); mh[u] = max(mh[u], mh[v]); if (mh[v] &gt; mh[son[u]]) { son[u] = v; } }}void tree_dp(int u) { int cost = 1; for (int i = 0; i &lt; e[u].size(); ++i) { int v = e[u][i]; if (v == son[u]) continue; cost = min(cost, dep[v]); tree_dp(v); dp[u] += dp[v] + cost; cost = mh[v] - dep[u] + 1; } if (son[u]) { cost = min(cost, dep[son[u]]); tree_dp(son[u]); dp[u] += dp[son[u]] + cost; }}signed main() { scanf(\"%lld\", &amp;T); for (int cas = 1; cas &lt;= T; ++cas) { scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= n; ++i) e[i].clear(), dp[i] = 0; for (int i = 2; i &lt;= n; ++i) { int f; scanf(\"%lld\", &amp;f); add(f, i); } dfs(1); tree_dp(1); printf(\"Case #%lld: %lld\\n\", cas, dp[1]); } return 0;}","link":"/DP/2020-ccpc-qinhuangdao-k-kingdom-s-power/"},{"title":"2020-2021 ICPC Kunming G. Gift","text":"其实这是签到题… 但是我们被带歪了根本没看… Solution 容易发现, 对于已经要做的蛋糕, 可以这样排列做蛋糕顺序: 按照生日的先后顺序. 于是先按生日排序后问题就有点类似背包: 用 $f[i][j][k]$ 表示用了前 $k$ 天处理 $i$ 个人的蛋糕并且有 $j$ 个人没有做的最大价值, 那么有: $$ f[i][j][k]=\\max\\{f[i-1][j-1][k],f[i-1][j][k-c[i]]+v[i]\\} $$ 且第二个转移方式有一定要求: $k\\geq c[i]$ 且 $k\\leq d[i]$ , $d[i]$ 表示第 $i$ 个人生日是在第几天. 然后暴力计算数组 $g$, $g[i]$ 表示选了最多 $i$ 个礼物可以获得的最大价值, 这里直接搜索或者枚举即可. 最后答案即为: $$ \\max\\{g[i]+f[n][i][365]\\} $$ 注意到本题卡常, $O(QNKD)$ 差不多 $5e8$ 了, 最后要滚动数组优化且减少一些状态数… Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#define INF (1e9 + 7)using namespace std;struct Node { int c, v, d; Node(int _c = 0, int _v = 0, int _d = 0) : c(_c), v(_v), d(_d) {} bool operator&lt;(const Node &amp;x)const { return d &lt; x.d; }};const int MAX_N = 5e2 + 7;const int MAX_M = 17;const int MAX_D = 367;Node fr[MAX_N];int dp[MAX_M][MAX_D], a[MAX_M], b[MAX_M], g[MAX_M], tmp[MAX_M][MAX_D], f[MAX_M];int mon[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};int T, n, m, w, ans;int get_day(int month, int day) { if (month == 2 &amp;&amp; day == 29) return 0; int res = 0; for (int i = 1; i &lt; month; ++i) res += mon[i]; return res + day;}int main() { scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;w); for (int i = 1; i &lt;= n; ++i) { int year, month, day; char ch; scanf(\"%d%c%d%c%d%d%d\", &amp;year, &amp;ch, &amp;month, &amp;ch, &amp;day, &amp;fr[i].c, &amp;fr[i].v); fr[i].d = get_day(month, day); } for (int i = 0; i &lt; m; ++i) scanf(\"%d%d\", a + i, b + i); for (int j = 0; j &lt;= m; ++j) { for (int k = 0; k &lt;= 365; ++k) { dp[j][k] = -INF; } g[j] = f[j] = -INF; } sort(fr + 1, fr + 1 + n); for (int k = 0; k &lt;= 365; ++k) dp[0][k] = 0; for (int i = 1; i &lt;= n; ++i) { for (int j = m; j &gt;= 0; --j) { for (int k = fr[i].d; k &gt;= 0; --k) { if (j != m) dp[j][k] = -INF; if (j) dp[j][k] = max(dp[j][k], dp[j - 1][k]); if (k &gt;= fr[i].c &amp;&amp; dp[j][k - fr[i].c] &gt;= 0) dp[j][k] = max(dp[j][k], dp[j][k - fr[i].c] + fr[i].v); f[j] = max(f[j], dp[j][k]); } } } for (int s = 0; s &lt; (1 &lt;&lt; m); ++s) { int cnt = 0, nw = 0, nv = 0; for (int i = 0; i &lt; m; ++i) { if ((s &gt;&gt; i) &amp; 1) nw += a[i], nv += b[i], ++cnt; } if (nw &lt;= w) g[cnt] = max(g[cnt], nv); } for (int i = 1; i &lt;= m; ++i) g[i] = max(g[i], g[i - 1]); ans = 0; for (int i = 0; i &lt;= m; ++i) ans = max(ans, g[i] + f[i]); printf(\"%d\\n\", ans); } return 0;}","link":"/DP/2020-2021-icpc-kunming-g-gift/"},{"title":"2020-2021 ICPC Kunming D. Competition Against a Robot","text":"这场比赛爬了… 是这样一个问题: 两个人 A, B 配合对抗机器人的游戏, 首先会有一个长度为 $n$ 的序列 $T$, 每个序列上由机器人规定一个 $0\\ldots,k-1$ 的数字, 并且机器人会产生一个整数字 $p(0\\leq p&lt;n)$, 游戏如下进行: A 先得到机器人的序列和数字 $p$, 但他能且只能选择序列上的某一个数字 $a$ , 将其变为 $(a+1)\\mod{k}$. 接下来 B 只会得到 A 操作过的序列, 他要由此猜出 $p$ 并获得胜利, 否则机器人胜利. 先给定 $n, k(n,k\\leq 10^{18})$ 和 $Q(Q\\leq 10^5)$ 次询问, 判断是机器人胜利还是人类. 弱化的一个问题 首先可以看 3Blue1Brown 提到的一个弱化的问题: 不可能的棋盘谜题 在这个问题中, $n = 64$ 而 $k = 2$. 其解决的方案是 A 将所有棋盘上为 $1$ 的序列下标(从 $0$ 开始)全部异或后再异或上 $p$, 然后把得到的数作为下标将棋盘上的那一位翻转. 而 B 只需要把每个为 $1$ 的序列下标异或即可得到 $p$. 这是因为 B 获得的答案可以由以下的公式给出: $$ p = ans(T’) = \\oplus_{i=0}^{63}i\\times T’(i) $$ $T’$ 是改变 $T$ 后得到的序列. 很明显, 如果 A 对 $i$ 进行操作则有: $$ ans(T’)=ans(T)\\oplus i $$ 于是只需要取 $i = p\\oplus^{-1} ans(T)=p\\oplus ans(T)$ 即可. 这样做可行的原因是 $\\oplus$ 对 ${0\\ldots,63}$ 封闭. 接下来考虑本题的这个问题, 人类获得胜利的充分必要条件是 $n\\mid k^n$. 必要性 首先我们可以发现, 机器人可以生成的序列 $T$ 有 $k^n$ 种, 其每种序列都可以通过 A 的 $n$ 种操作而转移到另外 $n$ 种序列, 而 $p$ 是多少 A 和 B 都不能事先预知, 也就是对于每个序列都要能转化到分别代表 $0,1,\\ldots,n-1$ 的 $n$ 种序列. 用图论的模型进行抽象的话也就是: 有一个有 $k^n$ 个经 $n$ 种颜色染色的结点的有向图, 其每个结点都有且仅有 $n$ 个出度, 并且这 $n$ 条边对应出去的结点颜色各不相同. 我们利用算两次的原理: 对于某一种颜色的结点, 每一个结点, 一定会有一条边对应到这种颜色的节点, 这样就计算了 $k^n$ 次. 另一方面, 由出边数量等于入边数量且由于对称性知道: 每一个结点有 $n$ 条入边, 所以该种颜色结点在上一种算法中各计算了 $n$ 次, 所以该种颜色结点数量为 $\\frac{k^n}{n}$. 故 $n\\mid k^n$. 充分性 接下来证明其充分性, 也就是对于 $n\\mid k^n$ 的情况, 我们要能构造出一组解使得人类获胜. 仿造前面的例子, 我们用类似方法去构造一组解. 首先考虑 $k$ 为素数的情况, 此时由于 $n\\mid k^n$, 故得: $n = k^t$. 由此可知对于任意的 $0,1,\\ldots, n-1$, 均可以用 $t$ 位的 $k$ 进制数来表示: $i = a_{t-1}k^{t-1}+\\ldots+a_0$. 定义 $a\\oplus b = (a+b)\\mod{k}$, $a\\otimes b=a\\times b\\mod{k}$, $\\oplus$ 的逆运算 $\\ominus$ 定义为 $a\\ominus b=(a-b)\\mod{k}$. 定义 $ans(T)$ 的计算方法: $$ ans(T)=\\oplus_{i=0}^{n-1}(i\\otimes T(i)) $$ 那么为了满足 $p=ans(T’)$, 则选择某一个 $i$ 操作有: $$ ans(T’)=ans(T)\\oplus i $$ 故 $i=p\\ominus ans(T)$. 若 $k=prime^{m}$, 则仍可以利用上文上述方法构造一组解. 因为若 $$ a\\equiv b(\\mod{m^t})\\Rightarrow a\\equiv b(\\mod m) $$ 对于 $k=p_1^{k_1}p_2^{k_2}\\ldots p_s^{k_s}$, $n = p_1^{\\alpha_1}p_2^{\\alpha_2}\\ldots p_s^{\\alpha_s}$ 的情况, 对于每一对 $(p_m,p_m^{\\alpha_m})$ 构造新的序列: $$ T(m,i)=\\left(\\sum_{j\\equiv i(\\mod{p_m^{\\alpha_m}})}T(j)\\right)\\mod{p_m^{\\alpha_m}} $$ 然后利用上面的方法, 构造一个解 $i’_{m}$. 满足 $ans(T’(m))\\equiv p(\\mod{p_m^{\\alpha_m}})$, 最后利用中国剩余定理知这两个不定方程组均有解, 则 A 解出 $i$ 并将其在模 $k$ 意义下加 $1$, 最后 B 通过计算 $ans(T’(m))$ 解得 $p$. 证毕. 实现 直接利用快速幂即可. 时间复杂度: $O(Q\\log n)$.","link":"/%E6%95%B0%E5%AD%A6/2020-2021-icpc-kunming-d-competition-against-a-robot/"},{"title":"2020-2021 ICPC Nanjing F.Fireworks","text":"F.Fireworks Solution 记最优期望为 $f$, 其第一次燃放剩余烟花在第 $k$ 次制造烟花之后, 那么显然有: $$ f = kn+m+q^kf $$ 故: $$ f=\\frac{kn+m}{1-q^k} $$ 其中, $q$ 为制造失败烟花的概率. 记 $f_k=\\frac{kn+m}{1-q^k}$, 那么答案为: $$ f=\\max_{k=1}^{\\infty} {f_k} $$ 做商: $$ \\begin{align*} &\\frac{f_{k+1}}{f_{k}}=\\frac{((k+1)n+m)\\times(1+q+q^2+\\ldots+q^{k-1})}{(kn+m)\\times(1+q+q^2+\\ldots+q^{k})} > 1\\\\ &\\Leftrightarrow n(1+q+\\ldots+q^{k-1})>(kn+m)q^k\\\\ &\\Leftrightarrow (a-1)+(a^2-1)+\\ldots+(a^k-1)>\\frac{m}{n}(a=\\frac{1}{q}) \\end{align*} $$ 也就是满足上不等式时, $f_{k+1}&gt;f_{k}$, 容易发现每当 $k$ 增大时, 左端式子也会增大, 因为 $a&gt;1$. 也就是左式单调增, $f_k$ 先减后增, 需要找到最小的 $k$ 满足上不等式. 所以利用二分答案即可. 注意到 $k$ 不必枚举很大, 由于 $\\frac{10000}{9999}$ 的 $210000$ 次方已经超过 $1e10$, 所以可以作为二分上界, 注意一些细节即可通过本题. Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define EPS 1e-9#define RINF 1e14#define int long longusing namespace std;const int INF = 2e5 + 1e4;int n, m, p, T;double q;double f_pow(double base, int b) { double res = 1; while (b) { if (base &gt; RINF || res &gt; RINF) return (RINF + 1); if (b &amp; 1) res = base * res; base = base * base; b &gt;&gt;= 1; } return res;}bool chk(int k) { double a = 1.0 / q; return a / (a - 1) * (f_pow(a, k) - 1) - k - 1.0 * m / n &gt; EPS;}double f(int n, int m, int k) { return 1.0 * (k * n + m) / (1 - f_pow(q, k));}signed main() { scanf(\"%lld\", &amp;T); while (T--) { scanf(\"%lld%lld%lld\", &amp;n, &amp;m, &amp;p); if (p == 10000) printf(\"%.10lf\\n\", (double)(n + m)); else { q = 1.0 * (10000 - p) / (10000); int l = 1, r = INF; while (l &lt; r) { int mid = (l + r) &gt;&gt; 1; if (chk(mid)) r = mid; else l = mid + 1; } printf(\"%.10lf\\n\", f(n, m, l)); } } return 0;} 文末 没开 long long 的我WA了三发… 队友对于推出的式子直接三分, 很牛逼, 但是我不会三分hh…","link":"/%E6%95%B0%E5%AD%A6/2020-2021-icpc-nanjing-f-fireworks/"},{"title":"2020-2021 ICPC Nanjing M. Monster Hunter","text":"M. Monster Hunter Solution 说是一种叫有依懒的背包问题. 于是先看一道例题: 例题: 有依赖的背包 这个问题中的物品关系形成一棵树, 一个物品可以被选当前仅当其父亲被选择. 故原背包问题的状态 f[i][k] 转移的难点在于不知道父亲是否被选. 为解决此问题, 考虑树形dp, 用 f[u][k] 表示当前结点必须选, 以此结点为根节点的子树在背包容量为 $k$ 时的最大价值. 接着不断合并儿子节点来更新当前结点的答案: $$ f[u][k] = \\max_{v\\in son(u)}\\{f[v][k - j]+f[u][j]\\} $$ 很显然, 这样的时间复杂度为 $O(n^3)$. 再看现在这题, 反过来考虑问题: 保留 $0,1,\\ldots, n$ 个结点可以得到的最小代价. 很容易发现一棵树的代价即为所有非根结点的代价的2倍+根节点的代价, 虽然这和接下来使用动态规划没有什么太大关系. 类似例题的方法, 用 f[u][k][0/1] 表示以 $u$ 为根的子树选了 $k$ 个点的最小代价($0$ 表示当前结点不选, $1$ 表示当前结点选). 容易得到转移: $$ f[u][k][0] = \\min_{v\\in son(u)}\\{f[v][j][0/1]+f[u][k-j][0]\\} $$ $$ f[u][k][1]=\\min_{v\\in son{(u)}}\\{f[v][j][0]+f[u][k-j][1],f[v][j][1]+f[u][k-j][1]+hp[v]\\} $$ 第二个方程是因为当父亲结点和儿子节点都选择那么儿子节点不是根, 故要再加上自己的代价. 但是容易发现这样的时间复杂度亦是: $O(n^3)$. TLE… 做一些优化, 可以发现对于某个结点 $u$, 在对某个儿子进行合并的时候, 当前可用的状态的第二维其实只有之前已经被合并的儿子的树的大小, 而对于当前儿子, 其第二维只有自己的树的大小. 但是这个复杂度似乎还是 $O(n^3)$ 的, 但是实际上这是一个不显然的结论, 实际上的复杂度为 $O(n^2)$! 接下来简单证明: 首先转移数为 $$ \\sum_{u\\in T}\\sum_{i=1}^{size\\ of\\ son(u)}siz[son(u,i)](1+siz[son(u,1)+\\ldots+siz[son(u,i-1)]]) $$ 接着对上面的式子简单放缩: $$ \\begin{align*} UHS&=\\sum_{u\\in T}siz[u]+\\sum_{u\\in T}\\sum_{i\\ne j}(siz[son[i]]siz[son[j]])\\\\ &\\leq h\\times n+\\frac{1}{2}\\sum_{u\\in T}\\left(\\sum siz[son[i]]+1\\right)^2-\\sum{siz^2[son[i]]}\\\\ &\\leq n^2+\\frac{1}{2}\\sum_{u\\in T}siz[u]^2-\\sum{siz^2[son[i]]}\\\\ &\\leq n^2+\\frac{1}{2}siz^2[root]\\\\ &=O(n^2) \\end{align*} $$ 证毕. Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define int long long#define INF 5e12using namespace std;struct Edge { int to, nxt; Edge(int _to = 0, int _nxt = 0) : to(_to), nxt(_nxt) {}};const int MAX_N = 2e3 + 7;Edge e[MAX_N];int dp[MAX_N][MAX_N][2], head[MAX_N], hp[MAX_N], siz[MAX_N];int T, n, cnt;void add(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt;}void dfs(int u) { dp[u][1][1] = hp[u], dp[u][0][0] = 0; siz[u] = 1; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; dfs(v); for (int k = siz[u]; k &gt;= 0; --k) { for (int j = siz[v]; j &gt;= 0; --j) { dp[u][j + k][0] = min(dp[u][j + k][0], min(dp[v][j][0] + dp[u][k][0], dp[v][j][1] + dp[u][k][0])); dp[u][j + k][1] = min(dp[u][j + k][1], min(dp[v][j][1] + dp[u][k][1] + hp[v], dp[v][j][0] + dp[u][k][1])); } } siz[u] += siz[v]; }}signed main() { scanf(\"%lld\", &amp;T); while (T--) { scanf(\"%lld\", &amp;n); cnt = 0; for (int i = 1; i &lt;= n; ++i) head[i] = 0; for (int i = 1; i &lt;= n; ++i) { for (int k = 0; k &lt;= n; ++k) { dp[i][k][0] = dp[i][k][1] = INF; } } for (int i = 2; i &lt;= n; ++i) { int p; scanf(\"%lld\", &amp;p); add(p, i); } for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", hp + i); dfs(1); for (int i = n; i; --i) { printf(\"%lld \", min(dp[1][i][0], dp[1][i][1])); } printf(\"%lld\\n\", min(dp[1][0][0], dp[1][0][1])); } return 0;}","link":"/%E5%9B%BE%E8%AE%BA/2020-2021-icpc-nanjing-m-monster-hunter/"},{"title":"CodeCraft-21 and CF Round #711(Div.2)","text":"因为先看 C 然后直接想歪, 爆零… A. B. 没看… C. 按 $k$ 的种数统计. D. E. F. Solution 先考虑 $k = 1$ 且树高只有 $1$. (树根深度为 $0$) 那么可以发现根节点的数字没有影响, 所以就是一个 $Nim$ 游戏, 只需要把第一层的数全部异或起来看是不是零; 若树高为 $2$, 那么可以发现, 对于第一层结点异或不为 $0$ 的情况, A 只需这样控制是自己仍然可以胜利: 若 B 选取第一层的数, 那么问题和 $Nim$ 相同, 否则将 B 从第二层移向第一层的数移到根, 则又和 $Nim$ 相同. 若第一层异或和为零, B 同样可以使用类似方法控制使得问题等价于 $ Nim$. 故只需要看第一层的数的异或和即可. 对于一般的树高, 可以发现对于奇数层异或和不为零的情况, A 和 B 均可类似上文所述方法进行控制使得最后问题等价于 $Nim$. 也就是答案取决于奇数层的异或和. 对于一般的 $k$, 那么前 $(k - 1)$ 仅相当与前面的 $0$ 层, 所以可以看出就是所有 $\\mod{2k} $ 余 $k, k+1, \\ldots, 2k-1$ 的异或和. 最后使用换根dp, 需要多维护一位状态 $k$ 表示余数. 时间复杂度: $O(nk)$. Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;struct Edge { int to, nxt; Edge(int _to = 0, int _nxt = 0) : to(_to), nxt(_nxt) {}};const int MAX_N = 1e5 + 7;Edge e[MAX_N &lt;&lt; 1];int head[MAX_N], dp[MAX_N][43], a[MAX_N], tmp[43];int n, k, cnt;void add(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt;}void dfs(int u, int fa) { dp[u][0] = a[u]; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (v == fa) continue; dfs(v, u); for (int j = 1; j &lt;= (k &lt;&lt; 1); ++j) { dp[u][j % (k &lt;&lt; 1)] ^= dp[v][j - 1]; } }}void chr(int u, int fa) { for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (v == fa) continue; for (int j = 0; j &lt; (k &lt;&lt; 1); ++j) tmp[j] = dp[v][j]; for (int j = (k &lt;&lt; 1); j; --j) { dp[v][j % (k &lt;&lt; 1)] ^= (tmp[(j - 2 + k + k) % (k &lt;&lt; 1)] ^ dp[u][(j - 1) % (k &lt;&lt; 1)]); } chr(v, u); }}int main() { scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt; n; ++i) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); add(u, v), add(v, u); } for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); dfs(1, 0); chr(1, 0); for (int i = 1; i &lt;= n; ++i) { int flag = 0; for (int j = k; j &lt; (k &lt;&lt; 1); ++j) flag ^= dp[i][j]; if (flag) { printf(\"1 \"); } else { printf(\"0 \"); } } puts(\"\"); return 0;}","link":"/CF/codecraft-21-and-cf-round-711-div-2/"},{"title":"Broadcast Stations","text":"题目链接 Solution 树形dp, 用 $f[u][k]$ 表示以当前点为根节点, 且当且可以向上传递 $\\geq k$ 的贡献并且其子树为全覆盖. 并用 $g[u][k]$ 表示所用距离 $u$ 小于等于 $k$ 并且将下方的所有结点覆盖的答案和的最小值. 方程转移考虑两个问题: 若当前点设置的 $p\\geq k$; 若当前点由儿子节点可以向上传递 $k$, 故可以向上传递 $k + 1$. 显然有 $g[u][k] = \\sum{g[v][k - 1]}$, $v$ 是 $u$ 的子结点. 另外对于 $f$ 的转移则为: $$ f[u][k] = min(f[u][k+1],k+g[u][k+1], f[v][k+1]+g[u][k+1]-g[v][k])(k&gt;0) $$ $$ f[u][0]=min(f[v][1]+g[u][1]-g[v][0]) $$ 时间复杂度: $O(n^2)$. Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;struct Edge { int to, nxt; Edge(int _to = 0, int _nxt = 0) : to(_to), nxt(_nxt) {}};const int MAX_N = 5e3 + 7;int dp[MAX_N][MAX_N], dps[MAX_N][MAX_N], head[MAX_N];Edge e[MAX_N &lt;&lt; 1];int n, cnt;void add(int x, int y) { e[++cnt].to = y; e[cnt].nxt = head[x]; head[x] = cnt;}void dfs(int u, int fa) { for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (v == fa) continue; dfs(v, u); for (int i = 1; i &lt;= n; ++i) dps[u][i] += dps[v][i - 1]; } dp[u][n] = n; for (int k = n - 1; k &gt;= 0; --k) { if (k) dp[u][k] = min(dp[u][k + 1], k + dps[u][k + 1]); else dp[u][k] = dp[u][k + 1]; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (v == fa) continue; dp[u][k] = min(dp[u][k], dp[v][k + 1] + dps[u][k + 1] - dps[v][k]); } } dps[u][0] = dp[u][0]; for (int k = 1; k &lt;= n; ++k) dps[u][k] = min(dps[u][k], dps[u][0]);}int main() { scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); add(u, v); add(v, u); } dfs(1, 0); printf(\"%d\\n\", dp[1][0]); return 0;}","link":"/%E5%9B%BE%E8%AE%BA/broadcast-stations/"},{"title":"AVATAR","text":"小时候看阿凡达的时候，看了一会便觉得十分无聊，很快就关掉了。最近阿凡达重映，听同学说是一部很好的电影，特效也非常好，由于也好长时间没去看电影了，便约了同学一同去看。 电影主要讲了一个为了获取潘多拉星球某种价值连城的矿石的地球人派出主角杰克前去与当地土著人纳威人谈判，欲求让他们搬出原来地下藏有大量矿石的家园，但最后时限已到而主角已经早意识到任务不可能完成而挑起战争，于是理所当然的杰克联合纳威人将地球人赶出潘多拉星球的故事。 对于关于“采矿”的态度，地球人阵营主要有两派，一方主要代表为一看就像坏人的高层人员帕克和霸气凛然的军官库里奇，他们认为要不惜代价甚至使用暴力夺取资源；另一方是为格蕾丝为代表的科学家们，他们希望和当地人交往学习，以和平方式解决问题。而在这种背景下主角的身份我觉得恰到好处，杰克 · 萨利是一名因战争下肢瘫痪的前海军战士，他将代替其死去的科学家弟弟去完成他的使命，这是由于阿凡达是由地球人和纳威人基因创造的生物，只有杰克能够操纵由弟弟基因创造的高成本阿凡达。这样一来，他其实不是科学家，但他其实也不在是士兵，而两方的对立使他陷入矛盾的处境。一方面，库里奇信任他曾是士兵，希望他帮助他们获取纳威人的信息以方便他们发动战争；而另一方面，格蕾丝希望他能够学习他们的文化，修复两球人濒临破碎的关系。而他，在纳威民族公主的教导下，最终坠入爱河，并由前一阵营转移到后一个阵营，而这一过程发生的很自然合理。电影最后的暴力反击我觉得就是比较“美国式”的，但更注重了整体的反击，而不是只有主角这一英雄奋勇杀敌。 我觉得该电影对人物刻画非常形象，且十分合理运用了故事背景和环境。主角使一个残废了的军官，一开始我不太理解，但是后面一看就明白了——活在阿凡达身上的杰克，重新站了起来，他一醒来就迫不及待冲到了外面，不停地奔跑；而这么喜悦的他和后面形成了对比，当库里奇军官告诉他任务完成，他可以功成身退，还可以帮他的腿治好，他却很冷静地要回到纳威人身边接受成为他们一员的仪式。其他人，女主、“备胎男”、格蕾丝、部落首领等我觉得他们都各得其所，形象到位。另外在故事背景方面，纳威人是个原始的民族，得知他们被杰克欺骗时他们十分生气，将杰克绑了起来，杰克最后为了拯救纳威人制服了神兽魅影，成为当地人认为的魅影骑士，由于封建的信仰，他成功拾回纳威人的信任。这样的设置，不仅不会让人觉得突兀莫名其妙，且不会有冗余的情节，我觉得恰到好处。 除了这些感触比较深的地方之外，电影的特效方面确实做得非常好，在一个未知的星球，可以充分发挥想象力，设计各种各样奇异的东西，并且没有令人感到一种夸张到觉得很“假”的感觉，10年前，这确实是十分不容易了。因为去得晚，没办法看IMAX，最后看了Star-MAX(哈哈哈)，音效方面比较一般。其他方面，诸如男女主角发展和多处杰克第一人称独白和视频记录生活这一设置等方面都值得赏析，限于水平一般，文笔也很烂，就不说了… 最后，当然是墙裂推荐去看。","link":"/Film/avatar/"},{"title":"ARC #115","text":"觉得很有意思的一场ARC, 虽然本菜鸡只写出了3个题… A. Two Choices Problem Statement $N$ students took a test with $M$ questions with two choices: $0$ and $1$. You are given $N$ strings of length $M$ each: $S_1,S_2,…,S_N$. The $k$-th character of $S_i$ is 0 or 1, representing the response of the $i$-th student to the $k$-th question. Although we know the response of each student to each question, we do not yet know the correct answer ― $0$ or $1$ ― to each problem. Find the number of pairs $(i,j)$ satisfying $1≤i&lt;j≤N$ such that it is impossible for Student $i$ and Student $j$ to have the same number of correct answers. Constraints $2\\leq N\\leq 10^5$ $1\\leq M \\leq 20$ $S_i$ is a string of length $M$ consisting of 0 and 1 Solution 容易发现如果两个人对的题数一定不同的话等价于恰好有奇数位数字不同. 再进一步可以发现, 任意交换 0 和1 , 不同题数的奇偶性不会改变, 所以就是统计奇数个 1 和偶数个 1 的各有多少个, 然后相乘即可. Code 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_M = 27;char s[MAX_M];int n, m, cnt_odd;signed main() { scanf(\"%lld%lld\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) { scanf(\"%s\", s + 1); int cnt = 0; for (int j = 1; j &lt;= m; ++j) if (s[j] == '1') ++cnt; if (cnt &amp; 1) ++cnt_odd; } printf(\"%lld\\n\", cnt_odd * (n - cnt_odd)); return 0;} B. Plus Matrix Problem Statement Given is an $N×N$ matrix $C$ whose elements are non-negative integers. Determine whether there is a pair of sequences of non-negative integers $A_1,A_2,…,A_N$ and $B_1,B_2,…,B_N$ such that $C_{i,j}=A_i+B_j$ for every $(i,j)$. If the answer is yes, print one such pair. Constraints $1\\leq N\\leq 500$ $0\\leq C_{i,j}\\leq 10^9$ Solution 可以发现任一行任意列相邻差相同, 由此判断然后随便乱构造即可. C. $\\mathbb{N}$ Coloring Problem Statements Given is an integer $N$. Among the sequences of $N$ positive integers $A_1,A_2,…,A_N$ satisfying the following condition, print one that minimizes the maximum value in the sequence. If $i$ divides $j$, $A_i≠A_j (1≤i&lt;j≤N)$. Constraints $1\\leq N\\leq 10^5$ Solution 利用数学归纳法可以证明 $A_i = \\Omega(i) + 1$. 其中 $$ \\Omega(i) = \\alpha_1+\\alpha_2+\\ldots+\\alpha_k $$ $$ i=p_1^{\\alpha_1}p_2^{\\alpha_2}\\ldots p^{\\alpha_k} $$ Code 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 1e5 + 7;int n;int mx_pos(int a) { int x = a, res = 0; for (int i = 2; i * i &lt;= x; ++i) { while (x % i == 0) ++res, x /= i; } if (x &gt; 1) ++res; return res;}int main() { scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) { printf(\"%d \", mx_pos(i) + 1); } puts(\"\"); return 0;} D. Odd Degree Problem Statements Given is a simple undirected graph with $N$ vertices and $M$ edges, where the vertices are numbered $1,…,N$ and the $i$-th edge connects Vertex $A_i$ and Vertex $B_i$. For each $K(0≤K≤N)$, find the number of spanning subgraphs (※) with exactly $K$ vertices with odd degrees. Since the answers can be enormous, print it modulo $998244353$. (※) A subgraph $H$ of $G$ is said to be a spanning subgraph of $G$ when the vertex set of $H$ equals the vertex set of $G$ and the edge set of $H$ is a subset of the edge set of $G$. Constraints $1\\leq N\\leq 5000$ $0\\leq M\\leq 5000$ $1\\leq A_i,B_i\\leq N$ The given graph is simple, that is, it contains no self-loops and no multi-edges. Solution 考虑图为一棵树的情况, 可以证明对任选的 $k$ 个固定点, 当 $k$ 为奇数时, 显然不可能存在只有 $k$ 个点的度数为奇数的情况, 这与欧拉握手定理相悖; 当 $k$ 为偶数时, 将存在唯一的子图使得这 $k$ 个点的度数恰好为奇数. 可以利用数学归纳法证明, 通过任选一个叶子结点, 进行讨论. 考虑连通图, 先任选棵图的生成树. 而其他的边不管加不加入, 其只会改变这 $k$ 个点的度数, 进而知道新的哪些具体的点度数为奇数, 并且不会改变奇度点的奇偶性. 故情况数为 $2^{m-n+1}C_{n}^{k}$. 最后对于多个连通图, 利用卷积计算总答案. 若不使用快速傅里叶变换的复杂度为 $O(n^2)$. Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 5e3 + 7;const int MOD = 998244353;int dp[MAX_N &lt;&lt; 1], f[MAX_N], siz_v[MAX_N], siz_e[MAX_N], tmp[MAX_N &lt;&lt; 1], tdp[MAX_N &lt;&lt; 1];int fac[MAX_N], inv_fac[MAX_N];int n, m, lst;int find(int x) { return x == f[x] ? x : f[x] = find(f[x]); }int f_pow(int base, int b, int mod = MOD) { int res = 1; while (b) { if (b &amp; 1) res = res * base % MOD; base = base * base % MOD; b &gt;&gt;= 1; } return res;}int C(int n, int m) { if (m &gt; n || m &lt; 0) return 0; return fac[n] * inv_fac[m] % MOD * inv_fac[n - m] % MOD;}signed main() { scanf(\"%lld%lld\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) f[i] = i, siz_v[i] = 1; fac[0] = 1, dp[0] = 1; for (int i = 1; i &lt;= n; ++i) fac[i] = fac[i - 1] * i % MOD; inv_fac[n] = f_pow(fac[n], MOD - 2); for (int i = n - 1; i &gt;= 0; --i) inv_fac[i] = inv_fac[i + 1] * (i + 1) % MOD; for (int i = 1; i &lt;= m; ++i) { int u, v; scanf(\"%lld%lld\", &amp;u, &amp;v); int x = find(u), y = find(v); if (siz_v[x] &gt; siz_v[y]) swap(x, y); if (x != y) f[x] = y, siz_v[y] += siz_v[x], siz_e[y] += siz_e[x]; ++siz_e[y]; } for (int i = 1; i &lt;= n; ++i) { if (i == find(i)) { int e = siz_e[i], v = siz_v[i]; // printf(\"%lld %lld\\n\", e, v); for (int k = 0; k &lt;= v; ++k) { if (k &amp; 1) { tmp[k] = 0; } else { tmp[k] = f_pow(2, e - v + 1) * C(v, k) % MOD; } } // for (int j = 0; j &lt;= v; ++j) printf(\"%lld \", tmp[j]); for (int j = 0; j &lt;= lst; ++j) { tdp[j] = dp[j]; dp[j] = 0; } for (int j = 0; j &lt;= lst; ++j) { for (int k = 0; k &lt;= v; ++k) { dp[j + k] = (dp[j + k] + tdp[j] * tmp[k] % MOD) % MOD; } } lst += v; } } for (int k = 0; k &lt;= n; ++k) printf(\"%lld\\n\", dp[k]); return 0;} E. LEQ and NEQ Problem statement Given is a sequence of $N$ integers $A_1,A_2,…,A_N$. Print the number, modulo $998244353$, of sequences of $N$ integers $X_1,X_2,…,X_N$ satisfying all of the following conditions: $1≤X_i≤A_i$ $X_i≠X_{i+1}(1≤i≤N−1)$ Constraints $2\\leq N\\leq 5\\times 10^5$ $1\\leq A_i\\leq 10^9$ Solution 容斥原理, 答案为确定有 $0$ 组相邻元素相同 $-$ 确定有 $1$ 组相邻元素相同 $+$ 确定有 $2$ 组相同… 利用动态规划, 用 $f[i][k]$ 表示考虑了前 $i$ 个, 确定有 $k$ 组相同的情况数. 则有转移: f[j][k + (j - i - 1)] += f[i][k] * min(a[i + 1], a[i + 2],..., a[j]) 注意到答案恰好为所有偶数的情况减去奇数的情况, 故对上面的状态进行优化, 用 $f[i][0/1]$ 表示所有偶数的情况数和所有奇数的情况数. 这样的时间复杂度为 $O(n^2)$. 可以发现对于每一个新添加的数 $a_i$, 以 $a_i$ 作为贡献的 $f[i][k]$ 是可以知道的, 对于该区间且位于 $i$ 之前的, 其对 $f[i]$ 的贡献均为 $f$ 乘 $a_i$, 而之前的保持不变. 所以相当于在维护区间的最小值, 可以借助笛卡尔树. 将时间复杂度优化至 $O(n)$. 另外为了方便统计答案, 记 $g[i] = f[i][0] - f[i][1]$, 过程中维护一个添加了区间最小值贡献的前缀和还有一个未添加最值的前缀和. 由递归性质, 逐项符号改变, 可以设偶数项的为正, 奇数为负, 注意细节及逻辑即可. Code 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 5e5 + 7;const int MOD = 998244353;int dp[MAX_N], sum[MAX_N], sp[MAX_N], st[MAX_N], a[MAX_N];int n, top;signed main() { scanf(\"%lld\", &amp;n); dp[0] = 1; for (int i = 1; i &lt;= n; ++i) { scanf(\"%lld\", a + i); while (top &amp;&amp; a[st[top]] &gt;= a[i]) { sum[i] = (sum[i] + sum[st[top--]]) % MOD; } sum[i] = (sum[i] + (i &amp; 1 ? 1ll : -1ll) * dp[i - 1]) % MOD; dp[i] = ((i &amp; 1 ? 1ll : -1ll) * (sum[i] * a[i] % MOD + sp[st[top]])) % MOD; sp[i] = (i &amp; 1 ? 1ll : -1ll) * dp[i]; st[++top] = i; } printf(\"%lld\\n\", (dp[n] + MOD) % MOD); return 0;} F. Migration 没看…","link":"/Atcoder/arc-115/"},{"title":"CF Round #708(Div.2)","text":"很魔幻的一次 Div.2, 开局没多久CF就崩了, 后来unrated了. 数学场, 主要是一些构造, 贪心还有动态规划的题目. 比赛时候主要一直绕着 E2 在想, 后面 D 舍友想了暴力贪心的做法, 写了半天… 最后好像假了: 舍友: 你要 AC 了. Wrong answer on test 1… 舍友: 你不可能 TLE. Time limit exceeded on test 2… A. Meximization Problem 对给定序列 $a$ 进行重排成 $b$, 使得 $$ \\sum_{i = 1}^{n}mex(b_1,b_2,\\ldots,b_i) $$ 最大. ( $t(1\\leq t\\leq 100)$ 组数据, $n\\leq 100$. ) Solution 由于 $mex(b_1,\\ldots, b_i)$ 不减, 所以就是从小到大输出, 相同的数多余的排到后面即可. 时间复杂度: $O(tn\\log n)$ B. M-arrays Problem 对给定序列 $a$ 进行重排并分为多个连续段, 使得每个段中相邻两数之和必须被给定数 $m(1\\leq m\\leq 10^5)$ 整除, 求段数的最小值. (多组数据, $\\sum{n}\\leq 10^5$) Solution 对模 $m$ 的完全剩余系简单讨论计算. C1. k-LCM (easy version) Problem 对给定的 $n(3\\leq n\\leq 10^9)$, 输出三个数 $a_1,a_2,a_3$ 满足: $$ a_1+a_2+a_3=n $$ $$ LCM(a_1,a_2,a_3)\\leq \\frac{n}{2} $$ $t$ 组数据. ($t\\leq 10^4$) Solution 若为奇数, 输出 $1, (n-1)/2, (n-1)/2$; 若为偶数: 若 $n/2$ 仍为偶数, 输出 $n/2, n/4, n/4$; 否则输出 $2, (n-2)/2, (n-2)/2$. C2. k-LCM (hard version) Problem 和 C1 几乎一致, 只是要输出 $k$ 个数而不是 $3$ 个. Solution 先输出 $(k-3)$ 个 $1$, 化为上一种情况. D. Genius Problem Please note the non-standard memory limit. There are $n$ problems numbered with integers from $1$ to $n$. $i$-th problem has the complexity $c_i=2^i$, tag $tag_i$ and score $s_i$. After solving the problem $i$ it’s allowed to solve problem $j$ if and only if $IQ&lt;|c_i−c_j|$ and $tag_i≠tag_j$. After solving it your $IQ$ changes and becomes $IQ=|c_i−c_j|$ and you gain $|s_i−s_j|$ points. Any problem can be the first. You can solve problems in any order and as many times as you want. Initially your $IQ=0$. Find the maximum number of points that can be earned. Input The first line contains a single integer $t (1≤t≤100)$ — the number of test cases. The first line of each test case contains an integer $n (1≤n≤5000)$ — the number of problems. The second line of each test case contains $n$ integers $tag_1,tag_2,…,tag_n$ $(1≤tag_i≤n)$ — tags of the problems. The third line of each test case contains $n$ integers $s_1,s_2,…,s_n$ $(1≤si≤10^9)$ — scores of the problems. It’s guaranteed that sum of $n$ over all test cases does not exceed $5000$. Output For each test case print a single integer — the maximum number of points that can be earned. Solution 注意到任何两个 $2$ 的幂次数相减不可能相同, 并且被减数越大值越大. 考虑动态规划, 用 $dp[i]$ 表示最后以 $i$ 问题结尾能获得的最大价值. 那么 $i: 1\\ldots n$, 而后遍历 $j:i-1\\ldots 1$, 转移: 一个是 $i$ 可以由 $j$ 转移, 另外 $j$ 可以由 $i$ 转移. 而以这个顺序进行就会使得 $\\vert c^i-c^j\\vert$ 递增, 就是 $IQ$ 是递增的. 时间复杂度: $O(n^2)$. Code 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 5e3 + 7;int dp[MAX_N], tag[MAX_N], s[MAX_N];int T, n, ans;signed main() { scanf(\"%lld\", &amp;T); while (T--) { scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", tag + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", s + i); for (int i = 1; i &lt;= n; ++i) dp[i] = 0; for (int i = 1; i &lt;= n; ++i) { for (int j = i - 1; j &gt; 0; --j) { if (tag[i] == tag[j]) continue; int dpi = dp[i], dpj = dp[j], v = abs(s[i] - s[j]); dp[i] = max(dp[i], dpj + v); dp[j] = max(dp[j], dpi + v); } } ans = dp[1]; for (int i = 2; i &lt;= n; ++i) ans = max(ans, dp[i]); printf(\"%lld\\n\", ans); } return 0;} E1. Square-free division (easy version) Problem This is the easy version of the problem. The only difference is that in this version $k=0$. There is an array $a_1,a_2,…,a_n$ of $n$ positive integers. You should divide it into a minimal number of continuous segments, such that in each segment there are no two numbers (on different positions), whose product is a perfect square. Moreover, it is allowed to do at most kk such operations before the division: choose a number in the array and change its value to any positive integer. But in this version $k=0$, so it is not important. What is the minimum number of continuous segments you should use if you will make changes optimally? Input The first line contains a single integer $t (1≤t≤1000)$ — the number of test cases. The first line of each test case contains two integers $n, k (1≤n≤2\\times 10^5, k=0)$. The second line of each test case contains $n$ integers $a_1,a_2,…,a_n (1≤a_i≤10^7)$. It’s guaranteed that the sum of $n$ over all test cases does not exceed $2\\times 10^5$. Output For each test case print a single integer — the answer to the problem. Solution 贪心策略, 首先预处理所有 $\\sqrt{1e7}$ 下的素数, 然后暴力质因数分解, 将素数因子的幂次为奇数的留下, 对于每个质因数可能和后面某个数相乘得到完全平方数就是后面某个数得到的素数因子序列和它相同. 暴力把素数扔进vector再套一个map. 复杂度大概为 $O(\\frac{n\\sqrt{a_{max}}}{\\log n}\\sigma{(a)}\\log n)$, 理论上不是很优秀, 但是实际跑得很快, 可能是没人卡吧. 另外其实可以直接把某个 $a$ 直接分解成 $A^2 B$, 其中 $B$ 不再有平方因子, 那么就是找后面哪个数也可以分解出一样的 $B$, 然后就要划分一次. 这样的复杂度大概是 $O(n)$ 的. Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 2e5 + 7;const int MAX_M = 1e7 + 7;const int MAX_P = 1e6 + 7;int pri[MAX_P];int vis[MAX_M];map&lt;vector&lt;int&gt;, bool&gt; mp;int T, n, cnt, ans, k;void Euler(int n) { for (int i = 2; i &lt;= n; ++i) { if (!vis[i]) { pri[++cnt] = i; vis[i] = true; } for (int j = 1; j &lt;= cnt &amp;&amp; i * pri[j] &lt;= n; ++j) { vis[i * pri[j]] = 1; if (i % pri[j] == 0) { break; } } }}void brute_force(int n) { int x = n, i; vector&lt;int&gt; nst; for (i = 1; pri[i] * pri[i] &lt;= n; ++i) { int tot = 0; while (x % pri[i] == 0) x /= pri[i], ++tot; if (tot &amp; 1) { nst.push_back(pri[i]); } } if (x &gt; 1) nst.push_back(x); if (mp[nst]) { ++ans; mp.clear(); } mp[nst] = true;}signed main() { Euler(1e4); scanf(\"%lld\", &amp;T); while (T--) { scanf(\"%lld%lld\", &amp;n, &amp;k); mp.clear(); ans = 1; for (int i = 1; i &lt;= n; ++i) { int a; scanf(\"%lld\", &amp;a); brute_force(a); } printf(\"%lld\\n\", ans); } return 0;} E2. square-free division (hard version) Problem $0\\leq k\\leq 20$. Solution 考虑动态规划, 用 $dp[i][j]$ 表示 $1\\ldots i$ 使用 $j$ 次变色最小分段数. 那么转移就是应该是利用 $t$ 次变色机会将 $l\\ldots i$ 变为一段进行转移. 所以我们需要预处理利用 $t$ 次机会将 $l\\ldots i$ 变为一段的 $l$, 并且尽可能最小化 $l$. 容易发现 $l$ 关于 $i$ 单调. 故利用双指针方法预处理 $O(nk)$, 总时间复杂度为 $O(nk^2)$. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 2e5 + 7;const int MAX_M = 1e7 + 7;int a[MAX_N], b[MAX_M], lft[MAX_N][23], dp[MAX_N][23];unordered_map&lt;int, int&gt; cnt;int T, n, k;signed main() { for (int i = 1; i * i &lt;= 1e7; ++i) { for (int j = 1; j * i * i &lt;= 1e7; ++j) { b[j * i * i] = j; } } scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), a[i] = b[a[i]]; for (int i = 1; i &lt;= n; ++i) { for (int j = 0; j &lt;= k; ++j) { dp[i][j] = n + 1; lft[i][j] = i; } } for (int j = 0; j &lt;= k; ++j) { int l = 1, now = 0; cnt.clear(); ++cnt[a[l]]; for (int i = 2; i &lt;= n; ++i) { if (cnt[a[i]] &gt; 0) ++now; ++cnt[a[i]]; while (now &gt; j) { if (cnt[a[l]] &gt; 1) --now; --cnt[a[l]]; ++l; } lft[i][j] = l; // printf(\"lft[%d][%d]: %d\\n\", i, j, lft[i][j]); } } for (int i = 1; i &lt;= n; ++i) { for (int j = 0; j &lt;= k; ++j) { for (int t = 0; t &lt;= j; ++t) { int l = lft[i][t]; dp[i][j] = min(dp[i][j], dp[l - 1][j - t] + 1); } } } printf(\"%d\\n\", dp[n][k]); } return 0;}","link":"/CF/cf-round-708-div-2/"},{"title":"数位DP","text":"数位DP主要用于求解 $[a,b]$ (其中 $a,b$ 很大) 中满足某一类要求的数的个数, 也就是区间计数. ABC#194.F Digits Paradise in Hexadecimal 题目大意 给定一个16进制正整数 $N(1\\leq N&lt; 16^{2\\times 10^5})$, 和一个10进制数 $K(1\\leq K\\leq 16)$, 求满足在区间 $[1, N]$ 中且各个数位数字种类个数为 $K$ 的16进制数的个数(不包括前导 $0$). 最后模一个数. 解题思路 考虑数位DP: 用 $f(pos, t, state, limit)$ 来表示状态, 其中 $pos$ 表示取到第 $i$ 位, $t$ 表示当前位数中出现数的种类数, $state$ 是一个2进制数, 用来表示当前状态选择了哪些数字, $limit$ 用来表示当前状态是否与原数的前 $i$ 位完全一致. 于是有了 $dfs$ 的版本: 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 2e5 + 7;const int MOD = 1e9 + 7;char s[MAX_N];int d[MAX_N], dp[MAX_N][17];int n, k;int dfs(int pos, int t, int limit, int state) { if (pos &gt;= n) return (t == k); if (!limit &amp;&amp; (dp[pos][t] != -1)) return dp[pos][t]; int mx = limit ? d[pos] : 15, res = 0; for (int j = 0; j &lt;= mx; ++j) { int nstate = state; if (j || state) nstate |= (1 &lt;&lt; j); res = (dfs(pos + 1, __builtin_popcount(nstate), limit &amp;&amp; (j == mx), nstate) + res) % MOD; } return limit ? res : dp[pos][t] = res;}signed main() { scanf(\"%s%lld\", s, &amp;k); n = strlen(s); for (int i = 0; i &lt; n; ++i) { if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') d[i] = s[i] - '0'; else d[i] = s[i] - 'A' + 10; } memset(dp, -1, sizeof dp); printf(\"%lld\\n\", dfs(0, 0, 1, 0)); return 0;} 另外的话, 还可以考虑非递归的版本, 用 $f[i][j]$ 表示取了 $i$ 位且当前有 $j$ 种数字出现了, 并且还满足: 取的数是严格小于原来的数 $N$ 的前 $i$ 位组成的数; 非零. 由此有递推公式, 首先由于前 $i$ 个数是严格小的, 于是新的一位可以随便填写之前出现过的 $j$ 种数字之一而转移到下一个状态 $f[i + 1][j]$, 或者同样的通过未出现过的 $(16-j)$ 种数字转移到 $f[i+1][j+1]$, 也即: $$ f[i+1][j]+=f[i][j]*j $$ $$ f[i+1][j+1]+=f[i][j]*(16-j) $$ 另外下一位不由上一位状态而来的可以是前面数字全为零, 而这时候只要随意添加一个非零数即可: $$ f[i+1][1]+=15 $$ 最后一种情况则为前 $i$ 位均与原数的前 $i$ 位相同, 那么这样的话下一位只能填 $0\\ldots d[i]-1$, 其中 $d[i]$ 即为在原数 $N$ 中的下一位数. 并且这个时候很容易就可以统计出当前状态的各数位上不同数字的个数, 然后进行转移即可. 于是有如下递推代码: 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 2e5 + 7;const int MOD = 1e9 + 7;char s[MAX_N];int d[MAX_N], dp[MAX_N][17];int n, k, state;signed main() { scanf(\"%s%lld\", s, &amp;k); n = strlen(s); for (int i = 0; i &lt; n; ++i) { if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') d[i] = s[i] - '0'; else d[i] = s[i] - 'A' + 10; } for (int i = 0; i &lt; n; ++i) { for (int j = 1; j &lt;= k; ++j) { dp[i + 1][j] = (dp[i + 1][j] + dp[i][j] * j % MOD) % MOD; dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j] * (16 - j) % MOD) % MOD; } if (i) dp[i + 1][1] = (dp[i + 1][1] + 15) % MOD; for (int j = 0; j &lt; d[i]; ++j) { int nstate = state; if (i || j) nstate |= (1 &lt;&lt; j); int st = __builtin_popcount(nstate); dp[i + 1][st] = (dp[i + 1][st] + 1) % MOD; } state |= (1 &lt;&lt; d[i]); } int st = __builtin_popcount(state); dp[n][st] = (dp[n][st] + 1) % MOD; printf(\"%lld\\n\", dp[n][k]); return 0;} 比较 正常来说, 所谓 $dfs$ 版本其实就是记忆化搜索版本的动态规划, 理论上状态数会比较少(略去了无用的状态), 但是另一方面其常数会比较大. 一般情况(个人经验), $dfs$ 效率较优, 但是对于此题, 数位高达 $2e5$, 递归反而更慢, 采取递推方式较好.","link":"/DP/%E6%95%B0%E4%BD%8Ddp/"},{"title":"tarjan算法求SCC/BCC","text":"SCC HDU 1269 迷宫城堡 12345678910111213141516171819202122void tarjan(int u) { dfn[u] = low[u] = ++order; st.push(u); for(int i = head[u]; i; i = e[i].next) { int v = e[i].to; if(!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); } else if(dfn[v] &lt; dfn[u]) { low[u] = min(low[u], dfn[v]); } } if(dfn[u] == low[u]) { int num = 0, tmp; do { tmp = st.top(); st.pop(); num++; }while(tmp != u); mx = max(mx, num); }} 割点 洛谷 P3388 【模板】割点（割顶） 1234567891011121314151617181920void tarjan(int u, int fa) { dfn[u] = low[u] = ++order; int child = 0; for(int i = head[u]; i; i = e[i].next) { int v = e[i].to; if(v == fa) continue; if(!dfn[v]) { child++; tarjan(v, u); low[u] = min(low[u], low[v]); if(low[v] &gt;= dfn[u] &amp;&amp; fa) { if(!point[u]) point[u] = true, ans++; } else if(!fa &amp;&amp; child &gt; 1) { if(!point[u]) point[u] = true, ans++; } } else if(dfn[v] &lt; dfn[u]) { low[u] = min(low[u], dfn[v]); } }} 点双连通分量 hihoCoder 连通性·四 123456789101112131415161718192021222324252627void tarjan(int u, int fa) { dfn[u] = low[u] = ++order; for(int i = head[u]; i; i = e[i].next) { int v = e[i].to; if(v == fa) continue; if(!dfn[v]) { int id = e[i].index; st.push(id); tarjan(v, u); low[u] = min(low[u], low[v]); if(low[v] &gt;= dfn[u]) { num++; mn[num] = INF; int tmp; do { tmp = st.top(); belong[tmp] = num; st.pop(); mn[num] = min(mn[num], tmp); }while(tmp != id); } } else if(dfn[v] &lt; dfn[u]) { st.push(e[i].index); low[u] = min(low[u], dfn[v]); } }} 边双连通分量及桥 洛谷 T102489 【模板】边双连通分量 POJ Redundant Paths 1234567891011121314151617181920212223242526272829303132void tarjan(int u, int fa) { dfn[u] = low[u] = ++order; bool flag = true; st.push(u); for(int i = head[u]; i; i = e[i].next) { int v = e[i].to; if(v == fa &amp;&amp; flag) { flag = false; continue; } if(!dfn[v]) { tarjan(v, u); low[u] = min(low[u], low[v]); if(low[v] &gt; dfn[u]) { bridge[i] = 1; if(i &amp; 1) bridge[i + 1] = 1; else bridge[i - 1] = 1; } } else if(dfn[v] &lt; dfn[u]) { low[u] = min(low[u], dfn[v]); } } if(dfn[u] == low[u]) { num++; int tmp; do{ tmp = st.top(); belong[tmp] = num; st.pop(); }while(tmp != u); }}","link":"/%E5%9B%BE%E8%AE%BA/tarjan%E7%AE%97%E6%B3%95%E6%B1%82scc-bcc/"},{"title":"绝对值最值","text":"题目 记 $(x_1,x_2,\\ldots,x_{20})$ 是 $(1,2,3,\\ldots,20)$ 的一个排列，并记 $$ S=\\sum_{i=1}^{20}\\vert x_i-i\\vert $$ 求 $S$ 的最值． 分析及解答 首先最小值我相信大家都能看出来，是零．只需要取 $$ x_i=i $$ 即可，并且结合 $S\\geq 0$ 即证． 所以关键问题在于最大值的求解．由于 $x_i$ 与 $i$ 的关系难以直接判断，造成难以继续下一步处理，其实大家应该也能猜到，其实我们可以有一种贪心的策略．什么意思呢，就是我按 $1,2,\\ldots,20$ 的顺序依次确定 $x_i$，而我每次取的时候都让 $\\vert x_i-i\\vert$ 尽可能的大，也就是这样： $i=1$ 时，取 $x_1=20$，则使得 $\\vert x_1-1\\vert$ 最大化； $i=2$ 时，由于这个时候 $20$ 已经被取过，于是取 $x_2=19$ ； $x_3=18$； $\\ldots$ $i=8$ 时，这时候有点问题，因为按上面的规律理应当取 $x_8=13$，但是很明显有 $$ \\vert 13-8\\vert=5&lt;\\vert 1-8\\vert $$ 也就是应当取 $x_8=1$； 接下来则都遵循 $x_i=i-7$，换言之 $\\vert x_i-i\\vert=7$． 那么取完之后可以计算一下结果： $$ \\begin{align*} S&=\\sum_{i=1}^{7}\\vert x_i-i\\vert+\\sum_{i=8}^{20}\\vert x_i-i\\vert\\\\ &=\\sum_{i=1}^{7}((21-i)-i)+7\\times (20-8+1)\\\\ &=21\\times 7-7\\times 8+7\\times 13\\\\ &=182 \\end{align*} $$ 但是这样好像有点问题，也的确证明不了是最大值，因为虽然越前面越大，但是后面好像却变小了．并且注意，这个方法还挺繁琐，竟然还要分类讨论．其实我们可以很容易联想到另外一个猜测，就是 $(x_1,x_2,\\ldots,x_{20})$ 刚好和原序列反过来，也就是 $$ (20,19,\\ldots,2,1) $$ 那先算一下答案，由对称性： $$ \\begin{align*} S&=2\\sum_{i=1}^{10}\\vert x_i-i\\vert\\\\ &=2(\\sum_{i=11}^{20}i-\\sum_{i=1}^{10}i)\\\\ &=21\\times 10-11\\times 10\\\\ &=200 \\end{align*} $$ 一看就会觉得这个答案靠谱很多．那到底是不是最大值呢？ 首先我们要说明这个问题的第一个障碍就是绝对值，为了方便观察，可以进行如下转换，注意到： $$ \\vert a-b\\vert=\\max\\{a,b\\}-\\min\\{a,b\\} $$ 意思就是说在 $\\vert x_i-i\\vert$ 中，$x_i$ 必定会作为 $\\max$ 或者是 $\\min$，剩下的就是 $i$．这样处理可以给我们一个全局的思考方向．因为 $x_i$ 还有 $i$ 其实都是 $1-20$ 之间的某一个数，也就是说对于任何一个 $i\\in {1,2,\\ldots,20}$，必定在 $\\max$ 或 $\\min$ 中出现两次．所以要最大化，只需要 $i&gt;10$ 时全部取到 $\\max$，$i&lt;11$ 时全部取到 $\\min$．也就是 $$ \\begin{align*} S&amp;\\leq2(\\sum_{i=11}^{20}i-\\sum_{i=1}^{10}i)\\ &amp;=200 \\end{align*} $$ 故最大值就是 $200$． 题外话 实际上一旦发现这点后可以知道 当 $i10$ 时，取 $x_i\\in\\{1,2,\\ldots,10\\}$． 啥意思？就是有 $(10!)^2$ 种取法．","link":"/%E6%95%B0%E5%AD%A6/%E7%BB%9D%E5%AF%B9%E5%80%BC%E6%9C%80%E5%80%BC/"},{"title":"luogu P2801 教主的魔法","text":"题目：P2801 教主的魔法 题目描述 教主最近学会了一种神奇的魔法，能够使人长高。于是他准备演示给XMYZ信息组每个英雄看。于是N个英雄们又一次聚集在了一起，这次他们排成了一列，被编号为1、2、……、N。 每个人的身高一开始都是不超过1000的正整数。教主的魔法每次可以把闭区间[L, R]（1≤L≤R≤N）内的英雄的身高全部加上一个整数W。（虽然L=R时并不符合区间的书写规范，但我们可以认为是单独增加第L（R）个英雄的身高） CYZ、光哥和ZJQ等人不信教主的邪，于是他们有时候会问WD闭区间 [L, R] 内有多少英雄身高大于等于C，以验证教主的魔法是否真的有效。 WD巨懒，于是他把这个回答的任务交给了你。 输入格式 第1行为两个整数N、Q。Q为问题数与教主的施法数总和。 第2行有N个正整数，第i个数代表第i个英雄的身高。 第3到第Q+2行每行有一个操作： （1） 若第一个字母为“M”，则紧接着有三个数字L、R、W。表示对闭区间 [L, R] 内所有英雄的身高加上W。 （2） 若第一个字母为“A”，则紧接着有三个数字L、R、C。询问闭区间 [L, R] 内有多少英雄的身高大于等于C。 输出格式 对每个“A”询问输出一行，仅含一个整数，表示闭区间 [L, R] 内身高大于等于C的英雄数。 输入输出样例 输入 #1 1234567895 31 2 3 4 5A 1 5 4M 3 5 1A 1 5 4 输出 #1 1223 说明/提示 【输入输出样例说明】 原先5个英雄身高为1、2、3、4、5，此时[1, 5]间有2个英雄的身高大于等于4。教主施法后变为1、2、4、5、6，此时[1, 5]间有3个英雄的身高大于等于4。 【数据范围】 对30%的数据，N≤1000，Q≤1000。 对100%的数据，N≤1000000，Q≤3000，1≤W≤1000，1≤C≤1,000,000,000。 分析 刚入门分块，以此作为练习。 初始化：将数组拆为 $\\sqrt{n}$ 个区间，查询时，如果区间覆盖了一个块，则直接输出块的答案。显然这样做最多只有两个块需要单独操作。 查询：本题不是查询区间和，为方便查找大于 $c$ 的数目，再用另外一个数组 $t[]$ 对区间进行排序，查询时利用二分查找即可。 区间增加：对于一整个区间被覆盖的情况，用 $dlt[]$ 数组将整个区间加上 $w$。边界处暴力增加。 时间复杂度：$O(Q\\sqrt{N}\\log N)$。 代码(C++) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;namespace iNx{ const int N = 1e6 + 7 ; const int SQN = 1e3 + 7 ; int a[N],t[N],st[SQN],ed[SQN],belong[N],size[SQN],dlt[SQN]; int n,q; void SORT(int x){ for(int i=st[x];i&lt;=ed[x];i++) t[i]=a[i]; sort(t+st[x],t+ed[x]+1); } void init(){ int num=sqrt(n); int i,j; for(i=0;i&lt;num;i++){ st[i+1]=n/num * i + 1; ed[i+1]=n/num * (i+1); } ed[num]=n; for(i=1;i&lt;=num;i++){ SORT(i); for(j=st[i];j&lt;=ed[i];j++) belong[j]=i; size[i]=ed[i]-st[i]+1; } } void modify(int l,int r,int c){ int x=belong[l],y=belong[r],i; if(x==y){ for(i=l;i&lt;=r;i++) a[i]+=c; SORT(x); return ; } for(i=l;i&lt;=ed[x];i++) a[i]+=c; for(i=st[y];i&lt;=r;i++) a[i]+=c; for(i=x+1;i&lt;y;i++) dlt[i]+=c; SORT(x); SORT(y); } int BF(int l,int r,int c,int x){ int ans=r+1,L=l,R=r,mid; while(L&lt;=R){ mid=(L+R)&gt;&gt;1; if(t[mid]+dlt[x]&gt;=c) ans=mid,R=mid-1; else L=mid+1; } return (r-ans+1); } int answer(int l,int r,int c){ int i,ans=0; int x=belong[l],y=belong[r]; if(x==y) return BF(l,r,c,x); ans+=BF(l,ed[x],c,x); ans+=BF(st[y],r,c,y); for(i=x+1;i&lt;y;i++) ans+=BF(st[i],ed[i],c,i); return ans; } void work(){ scanf(\"%d%d\",&amp;n,&amp;q); int i,l,r,c; char ch; for(i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); init(); for(i=1;i&lt;=q;i++){ ch=cin.peek(); while(ch==' '||ch=='\\n'||ch=='\\r'){ cin.get(); ch=cin.peek(); } ch=cin.get(); if(ch=='A'){ scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;c); printf(\"%d\\n\",answer(l,r,c)); } else if(ch=='M'){ scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;c); modify(l,r,c); } } }}int main(){ iNx::work(); return 0;}","link":"/%E5%88%86%E5%9D%97/luogu-p2801-%E6%95%99%E4%B8%BB%E7%9A%84%E9%AD%94%E6%B3%95/"},{"title":"KMP算法","text":"HDU 1711 Number Sequence Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 57954 Accepted Submission(s): 23132 Problem Description Given two sequences of numbers : a[1], a[2], … , a[N], and b[1], b[2], … , b[M] (1 &lt;= M &lt;= 10000, 1 &lt;= N &lt;= 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], … , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest one. Input The first line of input is a number T which indicate the number of cases. Each case contains three lines. The first line is two numbers N and M (1 &lt;= M &lt;= 10000, 1 &lt;= N &lt;= 1000000). The second line contains N integers which indicate a[1], a[2], … , a[N]. The third line contains M integers which indicate b[1], b[2], … , b[M]. All integers are in the range of [-1000000, 1000000]. Output For each test case, you should output one line which only contain K described above. If no such K exists, output -1 instead. Sample Input 1234567213 51 2 1 2 3 1 2 3 1 3 2 1 21 2 3 1 313 51 2 1 2 3 1 2 3 1 3 2 1 21 2 3 2 1 Sample Output 126-1 Source HDU 2007-Spring Programming Contest 代码 ++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;namespace iNx{ const int N = 1e6 + 10 ; const int M = 1e4 + 10 ; int a[N],b[M],next[M]; int n,m; void init(){ int i,k; for(i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); for(i=0;i&lt;m;i++) scanf(\"%d\",&amp;b[i]); next[0]=-1; i=0; k=-1; while(i&lt;m-1){ if(k==-1||b[i]==b[k]){ i++; k++; if(b[i]!=b[k]) next[i]=k; else next[i]=next[k]; } else k=next[k]; } } void work(){ scanf(\"%d%d\",&amp;n,&amp;m); if(n&lt;m){ printf(\"-1\\n\"); return ; } init(); int i=0,j=0; while(i&lt;n&amp;&amp;j&lt;m){ if(j==-1||a[i]==b[j]) i++,j++; else j=next[j]; } if(j==m) printf(\"%d\\n\",i-j+1); else printf(\"-1\\n\"); }}int main(){ int T; scanf(\"%d\",&amp;T); while(T--) iNx::work(); return 0;}","link":"/%E5%AD%97%E7%AC%A6%E4%B8%B2/kmp%E7%AE%97%E6%B3%95/"},{"title":"简单的偏微分方程（练习题）","text":"例题 已知微分方程 $$ \\frac{\\partial^2 u}{\\partial x^2}+\\frac{\\partial^2 u}{\\partial y^2}=0 $$ 有形如 $u=\\varphi(\\frac{y}{x})$ 的解，试求此解． 解 因为 $$ \\begin{align*} &\\frac{\\partial u}{\\partial x}=-\\frac{y}{x^2}\\varphi'\\\\ &\\frac{\\partial^2 u}{\\partial x^2}=2\\frac{y}{x^3}\\varphi'+\\frac{y^2}{x^4}\\varphi''\\\\ &\\frac{\\partial u}{\\partial y}=\\frac{1}{x}\\varphi'\\\\ &\\frac{\\partial^2 u}{\\partial y^2}=\\frac{1}{x^2}\\varphi'' \\end{align*} $$ 得到 $$ 2\\frac{y}{x^3}\\varphi’+\\frac{y^2}{x^4}\\varphi’’+\\frac{1}{x^2}\\varphi’’=0 $$ 很明显，两边同乘 $x^2$ 并令 $t=\\frac{y}{x}$ 即可化为常微分方程 $$ 2t\\varphi’+(t^2+1)\\varphi’’=0 $$ 这是一个一阶齐次线性微分方程，其实可以看出 $$ [(t^2+1)\\varphi’]’=0 $$ 于是 $$ \\varphi’=\\frac{C_1}{t^2+1} $$ 进一步积分得到 $$ \\varphi=C_1\\arctan{\\frac{y}{x}}+C_2 $$ 例题 设 $u=u(\\sqrt{x^2+y^2})$ 具有连续二阶偏导数，且满足 $$ \\frac{\\partial^2 u}{\\partial x^2}+\\frac{\\partial^2 u}{\\partial x^2}-\\frac{1}{x}\\cdot\\frac{\\partial u}{\\partial x}+u=x^2+y^2 $$ 求 $u$． 解 同样的计算 $u$ 的偏导数及二阶偏导数，并令 $t=\\sqrt{x^2+y^2}$ 将其化为常微分方程得： $$ u’’+u=t^2 $$ 其齐次通解为 $$ C_1\\cos t+C_2\\sin t $$ 容易求得一个特解 $$ y_p=t^2-2 $$ 将 $t=\\sqrt{x^2+y^2}$ 代入即可．","link":"/%E7%BB%83%E4%B9%A0%E9%A2%98/%E7%AE%80%E5%8D%95%E7%9A%84%E5%81%8F%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%EF%BC%88%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%89/"},{"title":"ODE常微分方程的微分算子法（1）","text":"常微分方程的微分算子法 定义 定义微分算子符号 $D^n=\\frac{d^n}{dx^n}$，则二阶线性微分方程 $$ y’’+Ay’+By=f(x) $$ 可以写成 $$ (D^2+AD+B)y=f(x) $$ 记多项式 $P(x)=x^2+Ax+B$，则又可以写成 $$ P(D)y=f(x) $$ 指数型 代换法则 描述 $$ P(D)e^{\\alpha x}=P(\\alpha)e^{\\alpha x} $$ $\\alpha$ 为复数． 证明 显然等价于证明 $$ D^n e^{\\alpha x}=\\alpha^n e^{\\alpha x} $$ 而这是显然的． 指数输入定理 描述 若 $P(D)y=e^{\\alpha x}$，则 $$ y_p=\\frac{e^{\\alpha x}}{P(\\alpha)}(while\\ P(\\alpha)\\neq0) $$ 其中 $y_p$ 表示一个特解． 证明 只需讲 $y_p$ 代入验证是方程的解即可，由代换法则 $$ \\begin{align*} P(D)y_p=&P(D)\\frac{e^{\\alpha x}}{P(\\alpha)}\\\\ =&\\frac{P(\\alpha)e^{\\alpha x}}{P(\\alpha)}\\\\ =&e^{\\alpha x} \\end{align*} $$ 证毕． 例题 求微分方程 $$ y’’-y’+2y=10e^{-x}\\sin x $$ 解： 先将方程复化 $$ (D^2-D+2)\\tilde{y}=10e^{(-1+i)x} $$ 方程特解 $y_p$ 即为 $\\tilde{y}_p$ 的虚部，由指数输入定理 $$ \\begin{align*} \\tilde y_p&=\\frac{10e^{(-1+i)x}}{(-1+i)^2-(-1+i)+2}\\\\ &=\\frac{10e^{(-1+i)x}}{-2i+1-i+2}\\\\ &=\\frac{10e^{-x}(\\cos x+i\\sin x)}{3-3i}\\\\ &=\\frac{10}{6}(1+i)e^{-x}(\\cos x+i\\sin x)\\\\ \\end{align*} $$ 因此，$y_p=$ $$ \\frac{5}{3}e^{-x}(\\sin x+\\cos x) $$ 那么如果 $p(\\alpha)=0$ 呢？ 指数移位法则 为与上面的情况区分，下面不再写 $\\alpha$ 而是 $a$，但是 $a$ 仍然可以是复数． 描述 $$ P(D)e^{ax}u(x)=e^{ax}P(D+a)u(x) $$ 证明 利用数学归纳法并且与代换法则相同，等价于证明单个算子的情况，即 $$ D^ne^{ax}u(x)=e^{ax}(D+a)^n u(x) $$ 在不引起歧义的前提下，下面将 $u(x)$ 写成 $u$ 而不影响理解． （1）当 $n=1$ 时 $$ D e^{ax}u=ae^{ax}u+e^{ax}Du=e^{ax}(D+a)u $$ 所以当 $n=1$ 时该法则正确． （2）当 $n=k-1$ 时成立 $$ \\begin{align*} D^ke^{ax}u&=D(D^{k-1}e^{ax}u)\\\\ &=D(e^{ax}(D+a)^{k-1}u)\\\\ &=e^{ax}(D+a)^ku \\end{align*} $$ 证毕． 一般性结论 首先来看二阶微分方程． 单根 若 $P(a)=0$ 且 $a$ 是单根，则有 $$ y_p=\\frac{xe^{ax}}{P’(a)} $$ 证明 因为 $a$ 是 $P(D)$ 的一个根，所以可以设 $$ P(D)=(D-a)(D-b) (a\\neq b) $$ 因此 $$ P’(D)=D-a+D-b $$ 也即 $$ P’(a)=a-b $$ 代入以检验解 $y_p$ 的正确性 $$ P(D)\\frac{e^{ax}x}{P’(a)}=\\frac{e^{ax}(D-b-a)Dx}{P’(a)}=\\frac{e^{ax}(a-b)}{(a-b)}=e^{ax} $$ 证毕． 二重根 若 $a$ 是二重根，则有 $$ y_p=\\frac{x^2e^{ax}}{P’’(a)} $$ 证明与前一种类似，设 $P(D)=(D-a)^2$ 进行检验即可． 例题 求 $$ y’’-3y+2y=e^x $$ 的特解． 解： $$ P(D)=D^2-3D+2 $$ $a=1$ 是单根（一重根），所以 $$ y_p=\\frac{xe^x}{P’(1)}=\\frac{xe^{x}}{2-3}=-xe^x $$ 更一般方程和 $n$ 重根 由前面两个例子，其实可以猜出： 当 $a$ 是 $n$ 重根时 $$ y_p=\\frac{e^{ax}x^n}{P^{(n)}(a)} $$ 其实将 $P(D)$ 理解为 $P^{(0)}(D)$，则上述结论为一般性结论，适用于任何情况． 证明 和前面的思路其实类似，关键在于怎么表示 $P(D)$ 已提取对我们最有利的部分． 设 $$ P(D)=(D-a)^n \\tilde{P}(D) $$ 则 $$ P^{(n)}(D)=n!\\tilde P(D)+(D-a)A(D) $$ 其中，$A(D)$ 是关于 $D$ 的多项式，可以看出来 $$ P^{(n)}(a)=n!\\tilde P(a) $$ 将 $y_p$ 代入方程检验 $$ \\begin{align*} P(D)\\frac{e^{ax}x^n}{P^{(n)(a)}}=&\\frac{e^{ax}P(D+a)x^n}{P^{(n)}(a)}\\\\ =&\\frac{e^{ax}\\tilde P(D+a)D^n x^n}{n! \\tilde P(a)}\\\\ =&\\frac{e^{ax}\\tilde P(D+a)\\times n!}{n! \\tilde P(a)}\\\\ =&\\frac{e^{ax}\\tilde P(a)\\times n!}{n! \\tilde P(a)}\\\\ =&e^{ax} \\end{align*} $$ 结语 在网上可以找到的算子法本就少之又少，大部分又只重结论，云里雾里，还需要多记很多麻烦的情况．例如三角函数，但是实际上只需要将三角函数复化就可以用指数的形式轻松解决，最后其实就只有一个公式．这次先谈到这，读者可以再多思考并做一些练习尝试，下次我再介绍 $f(x)$ 为多项式的情况．","link":"/%E6%95%B0%E5%AD%A6/ode%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E7%9A%84%E5%BE%AE%E5%88%86%E7%AE%97%E5%AD%90%E6%B3%95%EF%BC%881%EF%BC%89/"},{"title":"取值范围","text":"题目 函数 $f(x)=\\sqrt{2x-x^2}+x$ 的值域为____． 思考ing… 分析与解答 解法一 三角换元 注意到 $$ \\sqrt{2x-x^2}=\\sqrt{1-(x-1)^2} $$ 所以设 $x-1=\\sin \\alpha(\\alpha\\in[-\\frac{\\pi}{2},\\frac{\\pi}{2}])$，则 $f(x)=\\cos\\alpha+(1+\\sin\\alpha)$．于是 $$ \\begin{align*} f(x)&=1+\\sin\\alpha+\\cos\\alpha\\\\ &=1+\\sqrt{2}\\sin(\\alpha+\\frac{\\pi}{4})\\\\ &\\in[0,\\sqrt{2}+1] \\end{align*} $$ 解法二 柯西不等式 因为 $$ 1-(x-1)^2\\geq0\\Rightarrow x\\in[0,2] $$ 所以 $f(x)\\geq 0$，并且注意到，当 $x=0$ 时 $$ f(1)=0 $$ 即 $f(x)$ 最小值为 $0$． 另一方面，由柯西不等式 $$ \\begin{align*} f(x)&=\\sqrt{1-(x-1)^2}+x-1+1\\\\ &\\leq\\sqrt{(1-(x-1)^2+(x-1)^2)(1+1)}+1\\\\ &=\\sqrt{2}+1 \\end{align*} $$ 题外话 对于有根式和正常多项式的问题，三角和柯西不等式往往都能解决．可以权衡一下，找到更适合自己的方法．","link":"/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/"},{"title":"根式有理化","text":"问题来源 初中的时候曾经做过一道题, 题目具体是什么记不起来了. 记得最后发现用三角函数和用勾股定理得到的答案竟然不相同! 用三角函数计算得到的答案: $$ \\frac{\\sqrt{10}+\\sqrt{2}}{2} $$ 而用勾股定理开方算出来的是 $$ \\sqrt{3+\\sqrt{5}} $$ 当时考完听说有两答案还不信, 觉得是别人算错了, 结果自己一算还真是两个答案. 按计算器化简不出来, 但是求出估计值是一样的. 后面老师讲题也说其实两个都对, 这… 到底是为什么? 于是又去认真化了一下, 发现 $$ \\begin{align*} \\sqrt{3+\\sqrt{5}}=&\\sqrt{\\frac{6+2\\sqrt{5}}{2}} \\\\ =&\\sqrt{\\frac{(\\sqrt{5}+1)^2}{2}} \\\\ =&\\frac{\\sqrt{5}+1}{\\sqrt{2}} \\\\ =&\\frac{\\sqrt{10}+\\sqrt{2}}{2} \\end{align*} $$ 其实在这之前已经有遇到类似的例子, 比如 $$ \\sqrt{4-2\\sqrt{3}}=\\sqrt{3}-1 $$ 这些情况往往都一下子就看出来了, 为什么这道题却栽了跟头? 最主要的可能就是需要上下同乘 $2$ 才能比较直观地看出来可以配方. 所以觉得是不是当配不出来的时候就要上下同乘继续观察呢? 再看这个例子: $$ \\sqrt{5+\\sqrt{3}} $$ 能不能化简出来呢? 读者可以试一下, 但是可以发现这个尝试是无休止的. 但是还是不能说就不能. 思考与解决 所以接下来想的就是, 到底能不能有一个方法来判定能不能化简, 那么就可以省去许多尝试的时间. 所以我们需要建立一个一般情况的模型: $$ \\sqrt{x+\\sqrt{y}}=\\sqrt{a}+\\sqrt{b} $$ 其中 $a,b$ 不为根式, 求 $x,y$ 需要满足的条件. 为了更好地进行下一步分析, 我们再做一些处理. 对于 $\\sqrt{2-\\sqrt{3}}$, 由于其是 $\\frac{\\sqrt{4-2\\sqrt{3}}}{\\sqrt{2}}$ 可知能够化简. 也就是说对于任何的根式套根式, 必定能够利用通分, 化为 $$ \\frac{\\sqrt{x\\pm\\sqrt{y}}}{\\sqrt{z}} $$ 其中 $x,y,z$ 均为正整数. $\\sqrt{z}$ 显然不会影响化简, 所以问题等价于 $$ \\sqrt{x\\pm\\sqrt{y}} $$ 能否化简, 以分式类比, 我称其为&quot;根式有理化&quot;. 接下来进行我们的分析: 注意到: 如果有 $\\sqrt{x+\\sqrt{y}}=\\sqrt{a}+\\sqrt{b}$, 那么显然有 $\\sqrt{x-\\sqrt{y}}=\\sqrt{a}-\\sqrt{b}$. (记 $a&gt;b$)这对称性能不能带来帮助呢? 将其平方并写在一起进行观察: $$ \\begin{gather} x+\\sqrt{y}=a+b+2\\sqrt{ab}\\\\ x-\\sqrt{y}=a+b-2\\sqrt{ab} \\end{gather} $$ (1)+(2) 得 $$ a+b=x $$ (1)-(2) 得 $$ ab=\\frac{y}{4} $$ 也就是说, $a,b$ 是方程 $$ z^2-xz+\\frac{y}{4}=0 $$ 的两个根, 由于 $a,b$ 均为正整数, 故 $$ \\sqrt{\\Delta}=\\sqrt{x^2-y} $$ 必须为某个正整数 $N$, 也即 $x^2-y=N^2$ 是一个完全平方数. 至此已经得到了可以根式有理化的必要条件. 实际上, 这个条件不只是必要. 因为 $\\Delta$ 确定了, 其实两根 $a,b$ 也就确定了: $$ \\begin{cases} a=\\frac{x+N}{2} \\ b=\\frac{x-N}{2} \\end{cases} $$ 至此完全地解决了这个问题. 在此说一下一些初次尝试的人会犯的错, 比如 $$ \\sqrt{\\sqrt{13}-3} $$ 因为 $13-9=4$ 是完全平方数, 所以可以根式有理化? 这是不行的, 一定是带根号的比较小, 注意前面我们的证明.","link":"/%E6%95%B0%E5%AD%A6/%E6%A0%B9%E5%BC%8F%E6%9C%89%E7%90%86%E5%8C%96/"}],"tags":[{"name":"KMP","slug":"KMP","link":"/tags/KMP/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"微分方程","slug":"微分方程","link":"/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"数位DP","slug":"数位DP","link":"/tags/%E6%95%B0%E4%BD%8DDP/"},{"name":"ODE","slug":"ODE","link":"/tags/ODE/"},{"name":"练习题","slug":"练习题","link":"/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"分块","slug":"分块","link":"/tags/%E5%88%86%E5%9D%97/"},{"name":"CF","slug":"CF","link":"/tags/CF/"},{"name":"Atcoder","slug":"Atcoder","link":"/tags/Atcoder/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"Tree DP","slug":"Tree-DP","link":"/tags/Tree-DP/"},{"name":"背包","slug":"背包","link":"/tags/%E8%83%8C%E5%8C%85/"},{"name":"概率论","slug":"概率论","link":"/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"二分答案","slug":"二分答案","link":"/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","link":"/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"Moebius transform","slug":"Moebius-transform","link":"/tags/Moebius-transform/"},{"name":"状压DP","slug":"状压DP","link":"/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"递推","slug":"递推","link":"/tags/%E9%80%92%E6%8E%A8/"},{"name":"PE","slug":"PE","link":"/tags/PE/"},{"name":"Film","slug":"Film","link":"/tags/Film/"},{"name":"书法","slug":"书法","link":"/tags/%E4%B9%A6%E6%B3%95/"}],"categories":[{"name":"练习题","slug":"练习题","link":"/categories/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"图论","slug":"图论","link":"/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"DP","slug":"DP","link":"/categories/DP/"},{"name":"字符串","slug":"字符串","link":"/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"分块","slug":"分块","link":"/categories/%E5%88%86%E5%9D%97/"},{"name":"CF","slug":"CF","link":"/categories/CF/"},{"name":"Atcoder","slug":"Atcoder","link":"/categories/Atcoder/"},{"name":"Templates","slug":"Templates","link":"/categories/Templates/"},{"name":"CS: APP","slug":"CS-APP","link":"/categories/CS-APP/"},{"name":"数论","slug":"数论","link":"/categories/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","link":"/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"PE","slug":"PE","link":"/categories/PE/"},{"name":"Film","slug":"Film","link":"/categories/Film/"},{"name":"书法","slug":"书法","link":"/categories/%E4%B9%A6%E6%B3%95/"}]}