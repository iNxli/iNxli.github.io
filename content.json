{"pages":[{"title":"","text":"sNmlTFLhdP","link":"/baidu_verify_sNmlTFLhdP.html"},{"title":"","text":"漂泊的人。","link":"/about/index.html"}],"posts":[{"title":"templates for icpc","text":"Hey, password is required here. 26542699060710c6e1e50807ee25ca350c4d07acf1cb183c4db8c8f1db1a2d8646e7133ed5e8c9506f102b6f6398e9644382f7c29f3197db66617bf7bb7d9d2d020fcbb3889b508889489bc8052b8ab55ddaf3e9aff62291502bf9f8d59001f333def924047277a99f14eafaecf811ed636a0e8019927db1cf2cdbb687b54878a2ec222a75ebc229092f504735687be1ef9944f72b2c96e8ecf8bea78121cad77f2500e80ac9e7c36af7645eb1ecb46f924925dff7f564446114a07ad68962642639ff73887e974d68f72ec9c03509d7fe5351aa392a55fdc07c26d7f78d9adf08b452c7380eeb3a97e9987f9062599da1bdd39f290cac856c7aaec777f772da09dd4ad7d71c05d701ad41fc84eb0e6f","link":"/Templates/templates-for-icpc/"},{"title":"PE#540","text":"Counting primitive Pythagorean triples Solution 想了一个很爬的 $O(\\sqrt{n}\\log n)$ 的做法. 注意到本原勾股数的通解: 就是要找 $u, v$ 满足 $(u, v)=1$ 平方和小于等于 $n$ 且 $u, v$ 不同奇偶的组数. 所以就是计算: $$ \\sum_{u=1}^{\\sqrt{n}}\\sum_{v=1}^{\\min{(u, \\sqrt{n-u^2})}}[(u,v)=1{and} 2\\nmid (u-v)] $$ 依据 $v$ 的上限分成两部分处理: $u, \\sqrt{n-u^2}$. 对于第一种情况: 类似于求解欧拉函数, 但是奇数情况有所不同, 就是与其互素且是奇数的不能计算在内. 也就是计算偶数且与其互素的, 也就是求 $u/2$ 以下的与其互素的数个数, 根据: $(i,u)=(u-i,u)$ 知这部分答案为: $\\varphi(u)/2$. 对于第二部分: 记 $k=\\sqrt{n-u^2}$, $$ \\begin{align*} \\sum_{i=1}^{k}[(i,u)=1]&=\\sum_{i=1}^{k}\\sum_{t\\mid i\\\\ t\\mid u}\\mu{(t)}\\\\ &=\\sum_{t\\mid u}\\sum_{i=1}^{k}[t\\mid i]\\\\ &=\\sum_{t\\mid u}\\mu(t)\\lfloor \\frac{k}{t}\\rfloor \\end{align*} $$ 对于 $u$ 为奇数的情况, 式子中的 $k$ 应当为 $k/2$, 所以预处理一下卷积即可. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 6e7 + 7;int pri[MAX_N], phi[MAX_N], f[MAX_N], mu[MAX_N];int n, cnt, ans;void Euler(int n) { phi[1] = mu[1] = 1; for (int i = 2; i &lt;= n; ++i) { if (!phi[i]) { pri[++cnt] = i; phi[i] = i - 1; mu[i] = -1; } for (int j = 1; j &lt;= cnt &amp;&amp; 1ll * i * pri[j] &lt;= 1ll * n; ++j) { if (i % pri[j] == 0) { phi[i * pri[j]] = phi[i] * pri[j]; mu[i * pri[j]] = 0; break; } phi[i * pri[j]] = phi[i] * (pri[j] - 1); mu[i * pri[j]] = -mu[i]; } }}signed main() { scanf(\"%lld\", &amp;n); Euler(6e7); int sqr = (int)sqrt(n); for (int u = 1; u &lt;= sqr; ++u) { for (int i = u; i &lt;= sqr; i += u) { int k = sqrt(n - i * i); if (i &amp; 1) { f[i] += k / 2 / u * mu[u]; } else { f[i] += k / u * mu[u]; } } } int i; for (i = 2; i * i &lt;= n / 2; ++i) { if (i &amp; 1) { ans += phi[i] / 2; } else { ans += phi[i]; } } for ( ; i * i &lt;= n; ++i) { ans += f[i]; } printf(\"%lld\\n\", ans); return 0;}","link":"/PE/pe-540/"},{"title":"Educational Codeforces Round#107 E","text":"E. Colorings and Dominoes Solution 如果考虑某个骨牌对答案的贡献, 那么也就是其他的格子随便填的种数. 但是有可能会重复计算, 比如 “ooo”, 前两个作为骨牌放置和后面两个会有一种情况是重复计算贡献的, 因为可能有多种放骨牌方法, 但是价值却是一样的. 发现只有连续的行或列的格子会有相互影响, 考虑一个长列的&quot;价值&quot;, 然后其他位置随便填, 这时候贡献为: 当前列的价值 $\\times 2^{w-cnt}$, $cnt$ 为当前列长度. 复杂度: $O(nm\\log M)$. 递推类似斐波那契数列(相邻格子不相同方案数)的递推, 可以这样考虑: 用 $f[i]$ 表示考虑 $i$ 个格子的方案数. 那么当前格子有两种情况: ‘*’: 方案数为 $f[i-1]$; ‘o’: 考虑第 $i-1$ 的位置: ‘*’: $f[i-2]$; ‘o’: 强制连锁后面两个作为骨牌放置处, 最优价值肯定能由此构造, 故由 $f[i-2]$ 转移, 且要加上前面随便填的方案数: $2^{i-2}$. 即: $$ f[i]=f[i-1]+2f[i-2]+2^{i-2} $$ Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MOD = 998244353;const int MAX_N = 3e5 + 7;char mp[MAX_N];int dp[MAX_N];bool vis[MAX_N];int n, m, w, ans;int f_pow(int base, int b, int mod = MOD) { int res = 1; while (b) { if (b &amp; 1) res = res * base % mod; base = base * base % mod; b &gt;&gt;= 1; } return res;}void init(int n) { dp[1] = dp[0] = 0; for (int i = 2; i &lt;= n; ++i) { dp[i] = (dp[i - 1] + (dp[i - 2] &lt;&lt; 1) + f_pow(2, i - 2)) % MOD; }}signed main() { scanf(\"%lld%lld\", &amp;n, &amp;m); init(max(n, m)); for (int i = 1; i &lt;= n; ++i) { scanf(\"%s\", mp + 1 + (i - 1) * m); for (int j = 1; j &lt;= m; ++j) { if (mp[(i - 1) * m + j] == 'o') ++w; } } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= m; ++j) { if (!vis[(i - 1) * m + j] &amp;&amp; mp[(i - 1) * m + j] == 'o') { int cnt = 0; while (j &lt;= m &amp;&amp; !vis[(i - 1) * m + j] &amp;&amp; mp[(i - 1) * m + j] == 'o') { vis[(i - 1) * m + j] = true; ++cnt, ++j; } ans = (ans + dp[cnt] * f_pow(2, w - cnt) % MOD) % MOD; } } } memset(vis, 0, sizeof vis); for (int j = 1; j &lt;= m; ++j) { for (int i = 1; i &lt;= n; ++i) { if (!vis[(i - 1) * m + j] &amp;&amp; mp[(i - 1) * m + j] == 'o') { int cnt = 0; while (i &lt;= n &amp;&amp; !vis[(i - 1) * m + j] &amp;&amp; mp[(i - 1) * m + j] == 'o') { vis[(i - 1) * m + j] = true; ++cnt, ++i; } ans = (ans + dp[cnt] * f_pow(2, w - cnt) % MOD) % MOD; } } } printf(\"%lld\\n\", ans); return 0;} END zcxnb!","link":"/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/educational-codeforces-round-107-e/"},{"title":"Divide by Zero 2021 and CF Round #714(Div. 2)","text":"Divide by Zero 2021 and CF Round #714(Div. 2) A. Array and Peaks 可行条件是 $2k+1\\leq n$, 随便乱构造即可. B. AND Sequences 可以发现只要满足: $$ a_0=a_n=a_1\\& a_2\\& \\ldots\\& a_n $$ 即可. C. Add One 简单递推, 用 $f[i][k]$ 表示 $i$ 操作 $k$ 次后的长度, 有: $$ f[i][k]=f[1][k-10+i]+f[0][k-10+i] $$ 预处理之后 $O(\\log n)$ 回答即可. D. GCD and MST Solution 从小到大枚举公约数, 将以其为中心的所有可以连边的点检查和原来的 $p$ 的大小关系, 可以发现这些点之间不会再连新的边, 所以打上标记, $O(n)$ 扫描一遍即可. 复杂度: $O(n\\log n)$. Code 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 2e5 + 7;int a[MAX_N], ord[MAX_N];bool vis[MAX_N];int T, n, p, ans;bool cmp(const int &amp;x, const int &amp;y) { return a[x] &lt; a[y];}signed main() { scanf(\"%lld\", &amp;T); while (T--) { scanf(\"%lld%lld\", &amp;n, &amp;p); ans = p * (n - 1); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i), ord[i] = i, vis[i] = false; sort(ord + 1, ord + 1 + n, cmp); for (int i = 1; i &lt;= n; ++i) { int now = ord[i]; if (vis[now]) continue; if (a[now] &gt;= p) break; for (int j = now + 1; j &lt;= n &amp;&amp; a[j] % a[now] == 0; ++j) { ans += a[now] - p; if (vis[j]) break; vis[j] = true; } for (int j = now - 1; j &gt; 0 &amp;&amp; a[j] % a[now] == 0; --j) { ans += a[now] - p; if (vis[j]) break; vis[j] = true; } } printf(\"%lld\\n\", ans); } return 0;} E. Cost Equilibrium 可以发现到sink点或者source点多于一个时要全部放在一边, 然后简单讨论一下, 利用组合数学知识进行统计. F. Swapping Problem Solution 可以发现, 会对答案产生贡献的两个点一定是两个 $a$ 在中间或者两个 $b$ 在中间, 且贡献为重叠部分两倍的相反数. 也就说一个是 $a&lt;b$, 另一个是 $a&gt;b$, 最大化重叠部分. 故分类后进行排序, 可以发现排序后的数组应该满足 $a,b$ 均递增, 否则可以舍去. 所以可以直接对两种情况二分查找, 或者利用栈处理. 复杂度: $O(n\\log n)$. Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include &lt;bits/stdc++.h&gt;#define int long long#define INF (1e15 + 7)#define pii pair&lt;int, int&gt;using namespace std;struct Node { int x, y; Node(int _x = 0, int _y = 0) : x(_x), y(_y) {} bool operator&lt;(const Node &amp;u)const { if (x &lt; u.x) return true; if (x &gt; u.x) return false; return y &gt; u.y; }};const int MAX_N = 2e5 + 7;Node in[MAX_N], de[MAX_N];vector&lt;pii&gt; ab, ba;int a[MAX_N], b[MAX_N];int n, mx, dis;int low_bound(vector&lt;pii&gt; &amp;s, int x) { if (!s.size() || s.begin()-&gt;first &gt; x) return -1; int l = 0, r = s.size() - 1; while (l &lt; r) { int mid = (l + r + 1) &gt;&gt; 1; if (s[mid].first &lt;= x) l = mid; else r = mid - 1; } return s[l].second;} signed main() { // freopen(\"in.txt\", \"r\", stdin); scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", a + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", b + i); int n1 = 0, n2 = 0; for (int i = 1; i &lt;= n; ++i) { if (a[i] &lt; b[i]) in[++n1] = Node(a[i], b[i]); else if (a[i] &gt; b[i]) de[++n2] = Node(b[i], a[i]); dis += abs(a[i] - b[i]); } sort(in + 1, in + 1 + n1); sort(de + 1, de + 1 + n2); for (int i = 1; i &lt;= n1; ++i) { if (!ab.size() || in[i].y &gt; (ab.end() - 1)-&gt;second) { ab.push_back(pii(in[i].x, in[i].y)); } } for (int i = 1; i &lt;= n2; ++i) { if (!ba.size() || de[i].y &gt; (ba.end() - 1)-&gt;second) { ba.push_back(pii(de[i].x, de[i].y)); } } for (int i = 0; i &lt; ab.size(); ++i) { int y = low_bound(ba, ab[i].first); if (~y) mx = max(mx, min(y, ab[i].second) - ab[i].first); } for (int i = 0; i &lt; ba.size(); ++i) { int y = low_bound(ab, ba[i].first); if (~y) mx = max(mx, min(y, ba[i].second) - ba[i].first); } printf(\"%lld\\n\", dis - mx * 2); return 0;} END 写的函数传了一个vector形参直接不停TLE… 我到底还得爬多久…","link":"/CF/divide-by-zero-2021-and-cf-round-714-div-2/"},{"title":"AGC#053 A","text":"A - &gt;&lt; again 这么爬的我是不敢开AGC的, 然而昨天两个队友都在打? 赶紧看看他们做的啥题, 然后想了下A继续爬了… 因为此前做过一个问法类似的题, 不过是要分成两个序列, 然后一个升序/降序, 当时好像是推个什么不等式就好了. Solution 很明显看出答案具有单调性, 很大可能就是二分答案了. 发现原来的序列必定满足 $S$ 的要求, 现在考虑要分成 $k$ 组, 那么每组平均分配: $$ \\frac{a_1}{k},\\frac{a_2}{k},\\ldots,\\frac{a_n}{k} $$ 如果说这些数都是整数那么 $k$ 组显然是可行的. 如果不是整数呢? 那么为了获得&quot;整数&quot;, 可以利用带余数除法: $a_i=q_ik+r_i$. 取其中相邻一对: $q_i+r_i/k$ 和 $q_{i+1}+r_{i+1}/k$, 并且假定其大小关系为 $&lt;$. 那么就有三种情况: $q_i&gt;q_{i+1}$, 那么由于 $q_i+ri/k\\geq q_i\\geq q_{i+1}+1&gt;q_{i+1}+{r_{i+1}}/k$, 得出矛盾, 这种情况根本不可能出现; $q_i=q_{i+1}$, 那么有 $r_i&lt;r_{i+1}$, 但是注意需要 $k$ 组数全部满足 $&lt;$ 的条件, 而这时由于最终 $i$ 上的数 $a_i’$ 肯定比 $a_{i+1}’$ 小, 也就是 $a_i’\\leq a_{i+1}’-1$, 故得出 $a_i\\leq a_{i+1}-k$, 而这与 $q_i=q_{i+1} $ 矛盾, 所以若出现这种情况, 必不可能构造出解; $q_i&lt;q_{i+1}$, 再分两种情况: $q_i=q_{i+1}-1$, 那么如果某个 $q_i$ 加上了 $1$, 相应的 $q_{i+1}$ 也必须加 $1$, 而这时候候选的只有最多 $r_i,r_{i+1}$ 个 $1$, 所以如果 $r_{i}&gt;r_{i+1}$ 则无解; $q_{i}&lt;q_{i+1}-1$, 可以发现将前 $r_i,r_{i+1}$ 个数加 $1$, 是合法的构造. 更一般的, 当排除上述所有非法情况利用此方法容易发现是合法的全局构造. $O(N\\log(A_{max}))$, 感觉数据还可以大很多? Code 12345678910111213141516171819202122232425262728293031323334353637383940414243#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 1e2 + 7;char s[MAX_N];int a[MAX_N], q[MAX_N], r[MAX_N];int n;bool chk(int k) { for (int i = 0; i &lt;= n; ++i) q[i] = a[i] / k, r[i] = a[i] % k; for (int i = 0; i &lt; n; ++i) { if (q[i] == q[i + 1]) return false; if (s[i] == '&lt;') { if (q[i] + 1 == q[i + 1] &amp;&amp; r[i] &gt; r[i + 1]) return false; } else { if (q[i] - 1 == q[i + 1] &amp;&amp; r[i] &lt; r[i + 1]) return false; } } return true;}int main() { scanf(\"%d\", &amp;n); scanf(\"%s\", s); for (int i = 0; i &lt;= n; ++i) scanf(\"%d\", a + i); int k = 1, rt = 10000; while (k &lt; rt) { int mid = (k + rt + 1) &gt;&gt; 1; if (chk(mid)) k = mid; else rt = mid - 1; } printf(\"%d\\n\", k); for (int i = 0; i &lt;= n; ++i) q[i] = a[i] / k, r[i] = a[i] % k; for (int i = 1; i &lt;= k; ++i) { for (int j = 0; j &lt;= n; ++j) { if (i &lt;= r[j]) printf(\"%d \", q[j] + 1); else printf(\"%d \", q[j]); } puts(\"\"); } return 0;} End 看了下官方题解, 发现 $k$ 不用二分也能找出来, 构造方法则是一样的.","link":"/Atcoder/agc-053-a/"},{"title":"爬","text":"卡签到… 看错题… 连约数是 $O(log)$ 的都没想到… 想了两个 dp 复杂度全不对… 有谁比我更能爬?","link":"/uncategorized/%E7%88%AC/"},{"title":"202012CSP认证#4. 食材运输","text":"我太爬了… 一开始写个 $70$ 分做法都能把数组下标常量放错位置… 后面用真做法又是一边边界搞错… 一边连状态转移都能想复杂然后写错… Solution 首先对于 $k=m$ 的情况, 也就是运输车之间互不干扰, 只要对于每一种情况求出最小花费的时间, 然后总的再取一个大的时间. 计算最小的时间: 对于每种食材, 可以发现其路径总是从某一个结点开始然后&quot;转一圈&quot;但是不需要再返回. 于是可以枚举每个点作为开始的结点(根节点), 然后利用树形dp获得以该节点为起点的花费, 然后对每个点取最小值. 用 $dp[u]$ 表示运输车当前在 $u$ 结点, 处理这棵子树需要花费的时间. 贪心地去做, 应该把带权深度最深的结点放到最后一个计算, 因为这个点计算后就没有必要再回到 $u$ 了.(这里和ccpc秦皇岛那个k有点类似). 所以复杂度是 $O(n)$ 的, 那么总的复杂度就是 $O(n^2k)$. 可以过 $70%$, 但是我不知道我哪里又爬了… 获得了 $65$… 很容易想到这应该是一道状态dp的题目, 考虑状态 $f[i][j][S]$ 表示在前面 $i$ 个结点中, 选取了 $j$ 个结点作为检查点, 并且覆盖了 $k$ 种食材的集合 $S$ 的最小时间代价. 那么如果添加一个新的结点 $i + 1$, 就考虑要不要作为新的检查点, 若不用, 就直接由 $f[i][j][S]$ 转移; 否则应该考虑 $i+1$ 去覆盖另一个子集, 然后将其与当前子集并起来再更新. 这样转移的复杂度是 $O(2^k)$ 的, 会 TLE. 但是可以发现, 如果第 $(i+1)$ 个点决定覆盖某一种食材, 那么那些花费时间比这个时间要小的食材也都会被覆盖, 因为在一段时间内允许并行. 所以实际上转移的子集只有 $O(k)$ 个. 时间复杂度: $O(nm2^{k}k)$. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include &lt;bits/stdc++.h&gt;#define int long long#define INF (1e14 + 7)using namespace std;struct Edge{ int to, nxt, w;};const int MAX_N = 1e2 + 7;const int MAX_K = 17;const int MAX_S = (1 &lt;&lt; 10) + 7;Edge e[MAX_N &lt;&lt; 1];int in[MAX_N][MAX_K], dp[MAX_N], head[MAX_N], mh[MAX_N], dep[MAX_N], son[MAX_N], ext[MAX_N], st[MAX_N][MAX_K], ti[MAX_N][MAX_K], f[MAX_N][MAX_K][MAX_S];int cnt, now, n, m, k, ans;void add(int u, int v, int w) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt; e[cnt].w = w;}void dfs(int u, int fa) { ext[u] = in[u][now]; mh[u] = ext[u] ? dep[u] : 0; son[u] = 0; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (v == fa) continue; dep[v] = dep[u] + e[i].w; dfs(v, u); ext[u] = ext[u] | ext[v]; mh[u] = max(mh[u], mh[v]); if (ext[v] &amp;&amp; mh[son[u]] &lt; mh[v]) son[u] = v; }}void tree_dp(int u, int fa) { int cost = 0, costs; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (v == son[u]) costs = e[i].w; if (v == fa || v == son[u] || (!ext[v])) continue; tree_dp(v, u); dp[u] += cost + dp[v] + e[i].w; cost = mh[v] - dep[u]; } if (son[u]) tree_dp(son[u], u), dp[u] += cost + costs + dp[son[u]];}signed main() { scanf(\"%lld%lld%lld\", &amp;n, &amp;m, &amp;k); for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= k; ++j) { scanf(\"%lld\", &amp;in[i][j]); } } for (int i = 1; i &lt; n; ++i) { int u, v, w; scanf(\"%lld%lld%lld\", &amp;u, &amp;v, &amp;w); add(u, v, w); add(v, u, w); } for (int i = 1; i &lt;= n; ++i) { for (int j = 1; j &lt;= k; ++j) { now = j; memset(dp, 0, sizeof dp); dep[i] = 0; dfs(i, -1); tree_dp(i, -1); ti[i][j] = dp[i]; } for (int j = 1; j &lt;= k; ++j) { for (int t = 1; t &lt;= k; ++t) { if (ti[i][t] &lt;= ti[i][j]) st[i][j] |= 1 &lt;&lt; (t - 1); } } } for (int i = 0; i &lt;= n; ++i) { for (int j = 0; j &lt;= m; ++j) { for (int s = 0; s &lt; (1 &lt;&lt; k); ++s) { f[i][j][s] = INF; } } } for (int i = 0; i &lt;= m; ++i) f[0][i][0] = 0; for (int i = 0; i &lt; n; ++i) { for (int j = 0; j &lt;= m; ++j) { for (int s = 0; s &lt; (1 &lt;&lt; k); ++s) { for (int t = 1; t &lt;= k; ++t) { f[i + 1][j + 1][s | st[i + 1][t]] = min(max(f[i][j][s], ti[i + 1][t]), f[i + 1][j + 1][s | st[i + 1][t]]); f[i + 1][j][s] = min(f[i + 1][j][s], f[i][j][s]); } } } } printf(\"%lld\\n\", f[n][m][(1 &lt;&lt; k) - 1]); return 0;}","link":"/DP/202012csp%E8%AE%A4%E8%AF%81-4-%E9%A3%9F%E6%9D%90%E8%BF%90%E8%BE%93/"},{"title":"卷积: 变换与反演","text":"… 数论函数 在全体正整数(或全体整数)上定义的函数称作数论函数. 常见的数论函数 常数函数 $u(n)=1, n\\geq 1$ 恒等函数 $e_k(n)=n^k, n\\geq 1$ 单位函数 $I(n)=[n=1]$ $n$ 的因数个数除数函数: $d(n)=\\sum_{d\\mid n}1$ $n$ 的全部素因子个数: $$ \\Omega(n)=\\alpha_1+\\alpha_2+\\ldots+\\alpha_k,n=p_1^{\\alpha_1}p_2^{\\alpha_2}\\ldots p_{k}^{\\alpha_k} $$ $n$ 的不同素因子个数: $$ \\omega{(n)}=k, n =p_1^{\\alpha_1}p_2^{\\alpha_2}\\ldots p_{k}^{\\alpha_k} $$ $n$ 的正除数的幂和函数 $\\sigma_\\lambda(n)$: $$ \\sigma_\\lambda(n)=\\sum_{d\\mid n}d^{\\lambda} $$ 欧拉函数: $$ \\varphi(n)=\\sum_{d=1}^n [gcd(d, n)=1] $$ 莫比乌斯($M\\ddot{o}bius$)函数: $$ \\mu(n)= \\begin{cases} 1, n=1\\\\ (-1)^s, n = p_1p_2\\ldots p_s\\\\ 0, others\\\\ \\end{cases} $$ $Liouville$ 函数: $$ \\lambda(n)=(-1)^{\\Omega(n)} $$ 卷积 定义运算 $*$ : $$ (f*g)(n)=\\sum_{d\\mid n}f(d)g(\\frac{n}{d}) $$ 称运算 $*$ 为卷积运算或者 Dirichlet 乘积. 代数性质 简单利用配对的思想即可证明 $*$ 具有交换律. 可以证明: $f*g*h=\\sum_{abc=n}f(a)g(b)h(c)=f*(g*h)$ . 故其具有结合律. 另外容易发现有单位元 $I$ 使得: $$ f*I=I*f=f $$ 莫比乌斯变换 对于含有一个特殊函数常数函数 $u$ 的卷积: $$ F(n)=(f*u)(n)=\\sum_{d\\mid n}f(d) $$ 称 $F$ 为 $f$ 的莫比乌斯变换. 例如 $\\mu$ 的莫比乌斯变换为: $$ \\sum_{d\\mid n}\\mu(d)= \\begin{cases} 1, n=1\\\\ 0, n>1 \\end{cases} $$ 证明可以利用其只有单素数相乘的因子进行简单讨论得到. 特别的, $d(n)$ 是 $u(n)$ 的莫比乌斯变换. 另外可以看到: $$ I=\\mu * u $$ 也就是说 $u$ 是 $\\mu$ 的逆元. 事实上可以证明, 所有数论函数在所有数论函数构成的集合 $G$ 中都能找到其逆元. 也就是 $(G, *)$ 实际上构成了一个 Abel 群. 由上一个等式, 我们可以引出另一种变换, 也就是莫比乌斯反变换, 或称为莫比乌斯反演: $$ F=f*u\\Rightarrow f=F*\\mu $$ 利用前文所述性质即可简单证明. 我们知道: $$ n=\\sum_{d\\mid n}\\varphi(d) $$ 故 $e$ 是 $\\varphi$ 的莫比乌斯变换, 换言之: $\\varphi = e*\\mu$. 积性函数 若数论函数满足: $$ f(mn)=f(m)f(n),(m, n)=1 $$ 称 $f$ 为积性函数或者可乘函数. 特别的, 若可以没有 $(m,n)=1$ 这一条件则成为完全积性函数. 性质 $f(1)=1$. $f(n)=f(p_1^{\\alpha_1})f(p_2^{\\alpha_2})\\ldots f(p_{s}^{\\alpha_s})$. $f$ 的莫比乌斯变换仍为积性函数. 若 $g$ 也为积性函数, 则 $f*g$ 也为积性函数. 积性函数逆元亦为积性函数. 常见的 $\\mu,d,\\varphi$ 都是积性函数. 注意: 积性函数和加性函数很多都能利用线性筛或者其他筛法在线性或者更优时间内计算前缀和. 这为解决一些看似困难的问题提供的新的方法. 贝尔级数 贝尔级数可以帮我们计算各种乱七八糟的积性函数卷起来是什么函数. 定义数论函数 $f$ 在模素数 $p$ 意义下的贝尔级数: $$ f_p(x)=\\sum_{i=0}^{\\infty}f(p^i)x^i $$ 特别的, 对于完全积性函数 $f$, 有: $$ \\begin{align*} f_p(x)&=\\sum_{i=0}^{\\infty}f(p^i)x^i\\\\ &=\\sum_{i=0}^{\\infty}f^i(p)x^i\\\\ &=\\frac{1}{1-f(p)x} \\end{align*} $$ 注意此处我们不考虑其级数收敛性而假设其进行计算, 是为了利用下面的结论而帮助我们进行问题的分析和简化. 这让我们关注到了更本质的东西. 则有: $$ (f*g)_p=f_p\\times g_p $$ 就像 $Laplace$ 变换一样, 可以把卷积变成多项式的乘法, 对于某些问题的分析研究是有利的. 证明: 由前面的性质2可以知道只需要证明 $n=p^k$ 上述等式始终成立即可. $$ \\begin{align*} (f*g)_p(x)&=\\sum_{i=0}^{\\infty}\\left(\\sum_{j=0}^{i}f(p^i)g(p^{i-j})\\right)x^i\\\\ &=\\sum_{i=0}^{\\infty}f(p^i)x^i\\sum_{j=0}^{\\infty}f(p^j)x^j\\\\ &=(f_p\\times g_p)(x) \\end{align*} $$ 常见函数的贝尔级数 $\\mu_p(x)=1-x$ $e_p(x)=\\frac{1}{1-px}$ $\\varphi_p(x)=(\\mu_p\\times e_p)(x)\\frac{1-x}{1-px}$ $u_p(x)=\\frac{1}{1-x}$ 由 $\\mu_p\\times u_p=1$ 可以发现, 互为逆的两个数论函数的贝尔级数相乘恰好是 $1$. 莫比乌斯反演例题 其实这些叫做反演的题目没看出来用到了什么反演… 我只觉得用到了数论函数的一些性质. 莫比乌斯反演主要在对式子进行化简, 已达到类似如下的形式: $$ \\sum_{i=1}^n F(n/i)S(i) $$ 前者是与 $n/i$ 相关的函数, 可以利用数论分块进行处理, 后者一般是一个积性函数(或者加性), 因为积性函数往往可以通过线性时间预处理前缀和或者利用特殊方法(杜教筛, min_25筛)来快速计算前缀和. [HAOI2011]Problem b LCMSUM [国家集训队]Crash的数字表格 / JZPTAB 此题 OI wiki 上给的方法是用数论分块套数论分块. 其实可以只用一次. 我最后推出的式子是: $$ \\sum_{t=1}^{n}S(\\frac{n}{t})S(\\frac{m}{t})\\sum_{u\\mid t}u^2\\mu(u)\\frac{t}{u} $$ 其中 $S(n)=1+2+\\ldots+n$. 后面是一个卷积, 并且两个函数都是积性函数, 最后卷出来也是积性函数, 然后利用贝尔级数容易得到线性筛预处理出前缀和的方法. 其贝尔级数为: $$ 1+(p-p^2)x+(p^2-p^3)x^2+\\ldots $$ 所以素数就是 $p-p^2$. 如果是有一个素因子重复, 只需要乘 $p$ 就行了. 但是复杂度不变就是了. 「SDOI2015」约数个数和 简单的数学题 A Very Easy Math Problem 前面题目都是 OI wiki 上的例题, 就不多说了, 自己推推式子. 这题稍微化简一下得到: $$ \\sum_{t=1}^nS(\\frac{n}{t})t^{kx}\\sum_{u\\mid t}{\\mu(u)\\left(\\mu^2(\\frac{t}{u})\\cdot \\frac{t}{u}\\right)} $$ 其中 $S(n)=(\\sum_{i=1}^n i^k)^x$. 后面显然又是两个积性函数相乘, 其贝尔级数为: $$ f_p(x)=1+(p-1)x-px^2 $$ 当然因为这题要快速幂, 所以不做这个优化也无所谓, 直接 $O(n\\log n)$ 预处理卷积就行了. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MOD = 1e9 + 7;const int MAX_N = 2e5 + 7;int pri[MAX_N], mu[MAX_N], s[MAX_N];bool vis[MAX_N];int T, k, x, n, cnt, ans;void Euler(int n) { mu[1] = 1; for (int i = 2; i &lt;= n; ++i) { if (!vis[i]) { pri[++cnt] = i; mu[i] = -1; } for (int j = 1; j &lt;= cnt &amp;&amp; i * pri[j] &lt;= n; ++j) { vis[i * pri[j]] = true; if (i % pri[j] == 0) { mu[i * pri[j]] = 0; break; } mu[i * pri[j]] = -mu[i]; } }}int f_pow(int base, int b, int mod = MOD) { int res = 1; while (b) { if (b &amp; 1) res = res * base % mod; base = base * base % mod; b &gt;&gt;= 1; } return res;}void init(int n) { Euler(n); for (int i = 1; i &lt;= n; ++i) s[i] = (s[i - 1] + f_pow(i, k)) % MOD; for (int i = 1; i &lt;= n; ++i) s[i] = f_pow(s[i], x); memset(pri, 0, sizeof pri); for (int u = 1; u &lt;= n; ++u) { for (int t = u; t &lt;= n; t += u) { pri[t] = (pri[t] + mu[u] * mu[t / u] * mu[t / u] * t / u) % MOD; } } for (int i = 1; i &lt;= n; ++i) pri[i] = (pri[i] * f_pow(i, (k * x) % (MOD - 1)) % MOD + pri[i - 1]) % MOD;}signed main() { scanf(\"%lld%lld%lld\", &amp;T, &amp;k, &amp;x); init(2e5); while (T--) { scanf(\"%lld\", &amp;n); ans = 0; for (int i = 1, j; i &lt;= n; i = j + 1) { j = n / (n / i); ans = (ans + s[n / i] * (pri[j] - pri[i - 1]) % MOD) % MOD; } printf(\"%lld\\n\", (ans + MOD) % MOD); } return 0;} 参考资料 潘承洞: 《数论基础》, 2012年12月版; OI wiki: 莫比乌斯反演.","link":"/%E6%95%B0%E8%AE%BA/%E5%8D%B7%E7%A7%AF-%E5%8F%98%E6%8D%A2%E4%B8%8E%E5%8F%8D%E6%BC%94/"},{"title":"How to Get Popcount","text":"昨天晚上做 CS: APP 的 data lab 的时候, 在 howManyBits 这个函数的实现上爬了一万年… 很关键一点就是我不懂高效实现 popcount 的方法. 赶紧学习了一下, 发现自己真的需要好好学习… 我太 naive 了… popcount(x) 函数用于计算二进制表示的 $x$ 中有几个非零位(就是有几个 $1$). 很显然的一种方法就是逐位枚举并统计, 那么显然就是 $O(\\omega)$ 的, $\\omega$ 是位数, 比如 int 是 $32$ 位. 由于实际情况中 $1$ 的个数可能很少, 于是有另一种优化的方式. 利用 1x = x &amp; (x - 1); 这个操作会将 $x$ 最后一个 $1$ 清除, 那么只需要做 $popcount(x)$ 次即可. 但是注意到实际情况中可能出现全为 $1$ 的情况, 所以这个算法只做了部分的优化, 最终还是 $O(\\omega)$ 的. 这时候在网上看到一种天才算法: SWAR 算法(建议直接看这篇博客, 写得很清楚). 这个算法的具体实现如下: 12345int swar(uint32_t i) { i = i - ((i &gt;&gt; 1) &amp; 0x55555555); i = (i &amp; 0x33333333) + ((i &gt;&gt; 2) &amp; 0x33333333); return (((i + (i &gt;&gt; 4)) &amp; 0x0F0F0F0F) * 0x01010101) &gt;&gt; 24;} 这个算法基于一个事实: 对于一个只有两位数的二进制数: $(b_0b_1)$, 那么将其右移一位得到 $(0b_0)$, 将两数相减可以发现(令 $T((b_0b_1))=(b_0b_1)-(0b_0)$): $T((00))=(00)=0$, $T((01))=(01)=1$, $T((10))=(01)=1$, $T((11))=(10)=2$. 由此发现: $T((b_0b_1))$ 恰好就是 $(b_0b_1)$ 中 $1$ 的个数! 所以利用这个原理先将从原来的序列中获取&quot;一块块&quot;的 $1$ 的个数: 1x = x - ((x &gt;&gt; 1) &amp; 0x55555555) 也就是将整体移位后并将所有奇数位置为 $0$. (以 $32$ 位的 int 为例, 并且最后一位下标为 $0$) 接下来为了得到所有两位两位数之和, 再继续考虑两两配对的方法: 第一个和第二个数组成的二进制数加上第三个和第四个组成的二进制数, 第五个和第六个… 以此类推. 这么做完之后可以发现现在四位四位组成的二进制数已经恰好是其对应原来 $x$ 的那四位数字上 $1$ 的个数. 那么接着就是四个四个相加, 再八个八个相加, 最后十六个十六个相加得到的数就是我们要的 $popcount(x)$ 的值. 容易看出来这样的复杂度就是 $O(\\log \\omega)$ 的. 但是我们可以看到实际上的 SWAR 算法并不是这样实现的. 他只重复到了四个四个数的相加, 然后这样答案就应当是 $4$ 个 $8$ 位数的和, 这时候利用了乘法溢出后前面的位会被截断的技巧, 也就是 $\\times 0x01010101$. 这样可以使操作数大大减少. SWAR 算法还用到了另一个技巧, 那就是在这种情况下: (i + (i &gt;&gt; 4)) &amp; 0x0f0f0f0f 和 (i &amp; 0x0f0f0f0f) + ((i &gt;&gt; 4) &amp; 0x0f0f0f0f) 是相等的. 要注意与运算对于加法是没有分配律的, 但在这里是对的, 这是因为每个四位数大小实际上意味着原来的数的这四位上 $1$ 的个数. 那么显然是 $\\leq 4$ 的, 那么任意两个四位数相加都不会超过 $8$, 自然没有&quot;溢出&quot;的情况发生, 所以此处用法是正确的. 由此减少了一个 &amp; 的使用. 基于这个想法的其他算法好像也很多, 比如 hacker_popcnt 算法: 12345678int hacker_popcnt(uint32 x) { x -= (x &gt;&gt; 1) &amp; m1; x = (x &amp; m2) + ((x &gt;&gt; 2) &amp; m2); x = (x + (x &gt;&gt; 4)) &amp; m4; x += x &gt;&gt; 8; x += x &gt;&gt; 16; return x &amp; 0x7f;}","link":"/CS-APP/how-to-get-popcount/"},{"title":"2020 CCPC Qinhuangdao K. Kingdom's Power","text":"K. Kingdom’s Power 最近发现很多题目似乎都很类似… 这又是一道当时比赛时爬了半天最后还是不会的题目… solution 首先对于每个需要占领的点, 都有两种方式: 将已经占领过别的点的军队转移到此处; 从根节点重新派遣一支新的军队. 可以发现利用第二种方式是由于已经存在的军队到当前结点的距离小于根节点到当前结点的距离. 并且由此做简单的逻辑推导可以发现: 对于某一个结点的子树, 用于第二种方式的军队最多只会有一支. 并且总是从深度浅的到深度深的, 最后这支军队会到达该树最深处(满足不需要从根节点重新派遣的前提下的最深处). 这也就是贪心的做法. 考虑动态规划: 用 $f[u]$ 表示当前结点 $u$ 有一支军队, 接着要征服其子树需要多少时间. 那么我们将其子树按照最深深度由浅到深排序. 那么每次合并一个子树, 都要考虑是要从上个子树的最深处还是要从根节点的军队派遣一个到节点上, 所以记录上一子树的最深深度(为什么不考虑用于第二种方式的军队到达的最深处?)来更新这个状态的一个初始代价 $cost[v]$. 则有: $$ f[u]=\\sum_{v\\in son(u)}(f[v]+cost[v]) $$ 时间复杂度: $O(n\\log n)$. code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 1e6 + 7;int dp[MAX_N], dep[MAX_N], mh[MAX_N];vector&lt;int&gt; e[MAX_N];int T, n;bool cmp(const int &amp;x, const int &amp;y) { return mh[x] &lt; mh[y];}void add(int u, int v) { e[u].push_back(v);}void dfs(int u) { mh[u] = dep[u]; for (int i = 0; i &lt; e[u].size(); ++i) { int v = e[u][i]; dep[v] = dep[u] + 1; dfs(v); mh[u] = max(mh[u], mh[v]); } sort(e[u].begin(), e[u].end(), cmp);}void tree_dp(int u) { int cost = 1; for (int i = 0; i &lt; e[u].size(); ++i) { int v = e[u][i]; cost = min(cost, dep[v]); tree_dp(v); dp[u] += dp[v] + cost; cost = mh[v] - dep[u] + 1; }}signed main() { scanf(\"%lld\", &amp;T); for (int cas = 1; cas &lt;= T; ++cas) { scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= n; ++i) e[i].clear(), dp[i] = 0; for (int i = 2; i &lt;= n; ++i) { int f; scanf(\"%lld\", &amp;f); add(f, i); } dfs(1); tree_dp(1); printf(\"Case #%lld: %lld\\n\", cas, dp[1]); } return 0;} end 我不能再爬了, 抓紧时间学学 CS: APP 等有用的东西吧… 刚才睡了一觉然后想到, 其实前面的子树不按照大小排序也可以, 只要让深度最深的在最后面就可以了. 那么只要在 $dfs$ 的时候长链剖分即可. 复杂度: $O(n)$ ? 但是好像没快多少? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 1e6 + 7;int dp[MAX_N], dep[MAX_N], mh[MAX_N], son[MAX_N];vector&lt;int&gt; e[MAX_N];int T, n;bool cmp(const int &amp;x, const int &amp;y) { return mh[x] &lt; mh[y];}void add(int u, int v) { e[u].push_back(v);}void dfs(int u) { mh[u] = dep[u]; son[u] = 0; for (int i = 0; i &lt; e[u].size(); ++i) { int v = e[u][i]; dep[v] = dep[u] + 1; dfs(v); mh[u] = max(mh[u], mh[v]); if (mh[v] &gt; mh[son[u]]) { son[u] = v; } }}void tree_dp(int u) { int cost = 1; for (int i = 0; i &lt; e[u].size(); ++i) { int v = e[u][i]; if (v == son[u]) continue; cost = min(cost, dep[v]); tree_dp(v); dp[u] += dp[v] + cost; cost = mh[v] - dep[u] + 1; } if (son[u]) { cost = min(cost, dep[son[u]]); tree_dp(son[u]); dp[u] += dp[son[u]] + cost; }}signed main() { scanf(\"%lld\", &amp;T); for (int cas = 1; cas &lt;= T; ++cas) { scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= n; ++i) e[i].clear(), dp[i] = 0; for (int i = 2; i &lt;= n; ++i) { int f; scanf(\"%lld\", &amp;f); add(f, i); } dfs(1); tree_dp(1); printf(\"Case #%lld: %lld\\n\", cas, dp[1]); } return 0;}","link":"/DP/2020-ccpc-qinhuangdao-k-kingdom-s-power/"},{"title":"2020-2021 ICPC Kunming G. Gift","text":"其实这是签到题… 但是我们被带歪了根本没看… Solution 容易发现, 对于已经要做的蛋糕, 可以这样排列做蛋糕顺序: 按照生日的先后顺序. 于是先按生日排序后问题就有点类似背包: 用 $f[i][j][k]$ 表示用了前 $k$ 天处理 $i$ 个人的蛋糕并且有 $j$ 个人没有做的最大价值, 那么有: $$ f[i][j][k]=\\max\\{f[i-1][j-1][k],f[i-1][j][k-c[i]]+v[i]\\} $$ 且第二个转移方式有一定要求: $k\\geq c[i]$ 且 $k\\leq d[i]$ , $d[i]$ 表示第 $i$ 个人生日是在第几天. 然后暴力计算数组 $g$, $g[i]$ 表示选了最多 $i$ 个礼物可以获得的最大价值, 这里直接搜索或者枚举即可. 最后答案即为: $$ \\max\\{g[i]+f[n][i][365]\\} $$ 注意到本题卡常, $O(QNKD)$ 差不多 $5e8$ 了, 最后要滚动数组优化且减少一些状态数… Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#define INF (1e9 + 7)using namespace std;struct Node { int c, v, d; Node(int _c = 0, int _v = 0, int _d = 0) : c(_c), v(_v), d(_d) {} bool operator&lt;(const Node &amp;x)const { return d &lt; x.d; }};const int MAX_N = 5e2 + 7;const int MAX_M = 17;const int MAX_D = 367;Node fr[MAX_N];int dp[MAX_M][MAX_D], a[MAX_M], b[MAX_M], g[MAX_M], tmp[MAX_M][MAX_D], f[MAX_M];int mon[13] = {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};int T, n, m, w, ans;int get_day(int month, int day) { if (month == 2 &amp;&amp; day == 29) return 0; int res = 0; for (int i = 1; i &lt; month; ++i) res += mon[i]; return res + day;}int main() { scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d%d%d\", &amp;n, &amp;m, &amp;w); for (int i = 1; i &lt;= n; ++i) { int year, month, day; char ch; scanf(\"%d%c%d%c%d%d%d\", &amp;year, &amp;ch, &amp;month, &amp;ch, &amp;day, &amp;fr[i].c, &amp;fr[i].v); fr[i].d = get_day(month, day); } for (int i = 0; i &lt; m; ++i) scanf(\"%d%d\", a + i, b + i); for (int j = 0; j &lt;= m; ++j) { for (int k = 0; k &lt;= 365; ++k) { dp[j][k] = -INF; } g[j] = f[j] = -INF; } sort(fr + 1, fr + 1 + n); for (int k = 0; k &lt;= 365; ++k) dp[0][k] = 0; for (int i = 1; i &lt;= n; ++i) { for (int j = m; j &gt;= 0; --j) { for (int k = fr[i].d; k &gt;= 0; --k) { if (j != m) dp[j][k] = -INF; if (j) dp[j][k] = max(dp[j][k], dp[j - 1][k]); if (k &gt;= fr[i].c &amp;&amp; dp[j][k - fr[i].c] &gt;= 0) dp[j][k] = max(dp[j][k], dp[j][k - fr[i].c] + fr[i].v); f[j] = max(f[j], dp[j][k]); } } } for (int s = 0; s &lt; (1 &lt;&lt; m); ++s) { int cnt = 0, nw = 0, nv = 0; for (int i = 0; i &lt; m; ++i) { if ((s &gt;&gt; i) &amp; 1) nw += a[i], nv += b[i], ++cnt; } if (nw &lt;= w) g[cnt] = max(g[cnt], nv); } for (int i = 1; i &lt;= m; ++i) g[i] = max(g[i], g[i - 1]); ans = 0; for (int i = 0; i &lt;= m; ++i) ans = max(ans, g[i] + f[i]); printf(\"%d\\n\", ans); } return 0;}","link":"/DP/2020-2021-icpc-kunming-g-gift/"},{"title":"2020-2021 ICPC Kunming D. Competition Against a Robot","text":"这场比赛爬了… 是这样一个问题: 两个人 A, B 配合对抗机器人的游戏, 首先会有一个长度为 $n$ 的序列 $T$, 每个序列上由机器人规定一个 $0\\ldots,k-1$ 的数字, 并且机器人会产生一个整数字 $p(0\\leq p&lt;n)$, 游戏如下进行: A 先得到机器人的序列和数字 $p$, 但他能且只能选择序列上的某一个数字 $a$ , 将其变为 $(a+1)\\mod{k}$. 接下来 B 只会得到 A 操作过的序列, 他要由此猜出 $p$ 并获得胜利, 否则机器人胜利. 先给定 $n, k(n,k\\leq 10^{18})$ 和 $Q(Q\\leq 10^5)$ 次询问, 判断是机器人胜利还是人类. 弱化的一个问题 首先可以看 3Blue1Brown 提到的一个弱化的问题: 不可能的棋盘谜题 在这个问题中, $n = 64$ 而 $k = 2$. 其解决的方案是 A 将所有棋盘上为 $1$ 的序列下标(从 $0$ 开始)全部异或后再异或上 $p$, 然后把得到的数作为下标将棋盘上的那一位翻转. 而 B 只需要把每个为 $1$ 的序列下标异或即可得到 $p$. 这是因为 B 获得的答案可以由以下的公式给出: $$ p = ans(T’) = \\oplus_{i=0}^{63}i\\times T’(i) $$ $T’$ 是改变 $T$ 后得到的序列. 很明显, 如果 A 对 $i$ 进行操作则有: $$ ans(T’)=ans(T)\\oplus i $$ 于是只需要取 $i = p\\oplus^{-1} ans(T)=p\\oplus ans(T)$ 即可. 这样做可行的原因是 $\\oplus$ 对 ${0\\ldots,63}$ 封闭. 接下来考虑本题的这个问题, 人类获得胜利的充分必要条件是 $n\\mid k^n$. 必要性 首先我们可以发现, 机器人可以生成的序列 $T$ 有 $k^n$ 种, 其每种序列都可以通过 A 的 $n$ 种操作而转移到另外 $n$ 种序列, 而 $p$ 是多少 A 和 B 都不能事先预知, 也就是对于每个序列都要能转化到分别代表 $0,1,\\ldots,n-1$ 的 $n$ 种序列. 用图论的模型进行抽象的话也就是: 有一个有 $k^n$ 个经 $n$ 种颜色染色的结点的有向图, 其每个结点都有且仅有 $n$ 个出度, 并且这 $n$ 条边对应出去的结点颜色各不相同. 我们利用算两次的原理: 对于某一种颜色的结点, 每一个结点, 一定会有一条边对应到这种颜色的节点, 这样就计算了 $k^n$ 次. 另一方面, 由出边数量等于入边数量且由于对称性知道: 每一个结点有 $n$ 条入边, 所以该种颜色结点在上一种算法中各计算了 $n$ 次, 所以该种颜色结点数量为 $\\frac{k^n}{n}$. 故 $n\\mid k^n$. 充分性 接下来证明其充分性, 也就是对于 $n\\mid k^n$ 的情况, 我们要能构造出一组解使得人类获胜. 仿造前面的例子, 我们用类似方法去构造一组解. 首先考虑 $k$ 为素数的情况, 此时由于 $n\\mid k^n$, 故得: $n = k^t$. 由此可知对于任意的 $0,1,\\ldots, n-1$, 均可以用 $t$ 位的 $k$ 进制数来表示: $i = a_{t-1}k^{t-1}+\\ldots+a_0$. 定义 $a\\oplus b = (a+b)\\mod{k}$, $a\\otimes b=a\\times b\\mod{k}$, $\\oplus$ 的逆运算 $\\ominus$ 定义为 $a\\ominus b=(a-b)\\mod{k}$. 定义 $ans(T)$ 的计算方法: $$ ans(T)=\\oplus_{i=0}^{n-1}(i\\otimes T(i)) $$ 那么为了满足 $p=ans(T’)$, 则选择某一个 $i$ 操作有: $$ ans(T’)=ans(T)\\oplus i $$ 故 $i=p\\ominus ans(T)$. 若 $k=prime^{m}$, 则仍可以利用上文上述方法构造一组解. 因为若 $$ a\\equiv b(\\mod{m^t})\\Rightarrow a\\equiv b(\\mod m) $$ 对于 $k=p_1^{k_1}p_2^{k_2}\\ldots p_s^{k_s}$, $n = p_1^{\\alpha_1}p_2^{\\alpha_2}\\ldots p_s^{\\alpha_s}$ 的情况, 对于每一对 $(p_m,p_m^{\\alpha_m})$ 构造新的序列: $$ T(m,i)=\\left(\\sum_{j\\equiv i(\\mod{p_m^{\\alpha_m}})}T(j)\\right)\\mod{p_m^{\\alpha_m}} $$ 然后利用上面的方法, 构造一个解 $i’_{m}$. 满足 $ans(T’(m))\\equiv p(\\mod{p_m^{\\alpha_m}})$, 最后利用中国剩余定理知这两个不定方程组均有解, 则 A 解出 $i$ 并将其在模 $k$ 意义下加 $1$, 最后 B 通过计算 $ans(T’(m))$ 解得 $p$. 证毕. 实现 直接利用快速幂即可. 时间复杂度: $O(Q\\log n)$.","link":"/%E6%95%B0%E5%AD%A6/2020-2021-icpc-kunming-d-competition-against-a-robot/"},{"title":"2020-2021 ICPC Nanjing F.Fireworks","text":"F.Fireworks Solution 记最优期望为 $f$, 其第一次燃放剩余烟花在第 $k$ 次制造烟花之后, 那么显然有: $$ f = kn+m+q^kf $$ 故: $$ f=\\frac{kn+m}{1-q^k} $$ 其中, $q$ 为制造失败烟花的概率. 记 $f_k=\\frac{kn+m}{1-q^k}$, 那么答案为: $$ f=\\max_{k=1}^{\\infty} {f_k} $$ 做商: $$ \\begin{align*} &\\frac{f_{k+1}}{f_{k}}=\\frac{((k+1)n+m)\\times(1+q+q^2+\\ldots+q^{k-1})}{(kn+m)\\times(1+q+q^2+\\ldots+q^{k})} > 1\\\\ &\\Leftrightarrow n(1+q+\\ldots+q^{k-1})>(kn+m)q^k\\\\ &\\Leftrightarrow (a-1)+(a^2-1)+\\ldots+(a^k-1)>\\frac{m}{n}(a=\\frac{1}{q}) \\end{align*} $$ 也就是满足上不等式时, $f_{k+1}&gt;f_{k}$, 容易发现每当 $k$ 增大时, 左端式子也会增大, 因为 $a&gt;1$. 也就是左式单调增, $f_k$ 先减后增, 需要找到最小的 $k$ 满足上不等式. 所以利用二分答案即可. 注意到 $k$ 不必枚举很大, 由于 $\\frac{10000}{9999}$ 的 $210000$ 次方已经超过 $1e10$, 所以可以作为二分上界, 注意一些细节即可通过本题. Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;bits/stdc++.h&gt;#define EPS 1e-9#define RINF 1e14#define int long longusing namespace std;const int INF = 2e5 + 1e4;int n, m, p, T;double q;double f_pow(double base, int b) { double res = 1; while (b) { if (base &gt; RINF || res &gt; RINF) return (RINF + 1); if (b &amp; 1) res = base * res; base = base * base; b &gt;&gt;= 1; } return res;}bool chk(int k) { double a = 1.0 / q; return a / (a - 1) * (f_pow(a, k) - 1) - k - 1.0 * m / n &gt; EPS;}double f(int n, int m, int k) { return 1.0 * (k * n + m) / (1 - f_pow(q, k));}signed main() { scanf(\"%lld\", &amp;T); while (T--) { scanf(\"%lld%lld%lld\", &amp;n, &amp;m, &amp;p); if (p == 10000) printf(\"%.10lf\\n\", (double)(n + m)); else { q = 1.0 * (10000 - p) / (10000); int l = 1, r = INF; while (l &lt; r) { int mid = (l + r) &gt;&gt; 1; if (chk(mid)) r = mid; else l = mid + 1; } printf(\"%.10lf\\n\", f(n, m, l)); } } return 0;} 文末 没开 long long 的我WA了三发… 队友对于推出的式子直接三分, 很牛逼, 但是我不会三分hh…","link":"/%E6%95%B0%E5%AD%A6/2020-2021-icpc-nanjing-f-fireworks/"},{"title":"2020-2021 ICPC Nanjing M. Monster Hunter","text":"M. Monster Hunter Solution 说是一种叫有依懒的背包问题. 于是先看一道例题: 例题: 有依赖的背包 这个问题中的物品关系形成一棵树, 一个物品可以被选当前仅当其父亲被选择. 故原背包问题的状态 f[i][k] 转移的难点在于不知道父亲是否被选. 为解决此问题, 考虑树形dp, 用 f[u][k] 表示当前结点必须选, 以此结点为根节点的子树在背包容量为 $k$ 时的最大价值. 接着不断合并儿子节点来更新当前结点的答案: $$ f[u][k] = \\max_{v\\in son(u)}\\{f[v][k - j]+f[u][j]\\} $$ 很显然, 这样的时间复杂度为 $O(n^3)$. 再看现在这题, 反过来考虑问题: 保留 $0,1,\\ldots, n$ 个结点可以得到的最小代价. 很容易发现一棵树的代价即为所有非根结点的代价的2倍+根节点的代价, 虽然这和接下来使用动态规划没有什么太大关系. 类似例题的方法, 用 f[u][k][0/1] 表示以 $u$ 为根的子树选了 $k$ 个点的最小代价($0$ 表示当前结点不选, $1$ 表示当前结点选). 容易得到转移: $$ f[u][k][0] = \\min_{v\\in son(u)}\\{f[v][j][0/1]+f[u][k-j][0]\\} $$ $$ f[u][k][1]=\\min_{v\\in son{(u)}}\\{f[v][j][0]+f[u][k-j][1],f[v][j][1]+f[u][k-j][1]+hp[v]\\} $$ 第二个方程是因为当父亲结点和儿子节点都选择那么儿子节点不是根, 故要再加上自己的代价. 但是容易发现这样的时间复杂度亦是: $O(n^3)$. TLE… 做一些优化, 可以发现对于某个结点 $u$, 在对某个儿子进行合并的时候, 当前可用的状态的第二维其实只有之前已经被合并的儿子的树的大小, 而对于当前儿子, 其第二维只有自己的树的大小. 但是这个复杂度似乎还是 $O(n^3)$ 的, 但是实际上这是一个不显然的结论, 实际上的复杂度为 $O(n^2)$! 接下来简单证明: 首先转移数为 $$ \\sum_{u\\in T}\\sum_{i=1}^{size\\ of\\ son(u)}siz[son(u,i)](1+siz[son(u,1)+\\ldots+siz[son(u,i-1)]]) $$ 接着对上面的式子简单放缩: $$ \\begin{align*} UHS&=\\sum_{u\\in T}siz[u]+\\sum_{u\\in T}\\sum_{i\\ne j}(siz[son[i]]siz[son[j]])\\\\ &\\leq h\\times n+\\frac{1}{2}\\sum_{u\\in T}\\left(\\sum siz[son[i]]+1\\right)^2-\\sum{siz^2[son[i]]}\\\\ &\\leq n^2+\\frac{1}{2}\\sum_{u\\in T}siz[u]^2-\\sum{siz^2[son[i]]}\\\\ &\\leq n^2+\\frac{1}{2}siz^2[root]\\\\ &=O(n^2) \\end{align*} $$ 证毕. Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include &lt;bits/stdc++.h&gt;#define int long long#define INF 5e12using namespace std;struct Edge { int to, nxt; Edge(int _to = 0, int _nxt = 0) : to(_to), nxt(_nxt) {}};const int MAX_N = 2e3 + 7;Edge e[MAX_N];int dp[MAX_N][MAX_N][2], head[MAX_N], hp[MAX_N], siz[MAX_N];int T, n, cnt;void add(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt;}void dfs(int u) { dp[u][1][1] = hp[u], dp[u][0][0] = 0; siz[u] = 1; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; dfs(v); for (int k = siz[u]; k &gt;= 0; --k) { for (int j = siz[v]; j &gt;= 0; --j) { dp[u][j + k][0] = min(dp[u][j + k][0], min(dp[v][j][0] + dp[u][k][0], dp[v][j][1] + dp[u][k][0])); dp[u][j + k][1] = min(dp[u][j + k][1], min(dp[v][j][1] + dp[u][k][1] + hp[v], dp[v][j][0] + dp[u][k][1])); } } siz[u] += siz[v]; }}signed main() { scanf(\"%lld\", &amp;T); while (T--) { scanf(\"%lld\", &amp;n); cnt = 0; for (int i = 1; i &lt;= n; ++i) head[i] = 0; for (int i = 1; i &lt;= n; ++i) { for (int k = 0; k &lt;= n; ++k) { dp[i][k][0] = dp[i][k][1] = INF; } } for (int i = 2; i &lt;= n; ++i) { int p; scanf(\"%lld\", &amp;p); add(p, i); } for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", hp + i); dfs(1); for (int i = n; i; --i) { printf(\"%lld \", min(dp[1][i][0], dp[1][i][1])); } printf(\"%lld\\n\", min(dp[1][0][0], dp[1][0][1])); } return 0;}","link":"/%E5%9B%BE%E8%AE%BA/2020-2021-icpc-nanjing-m-monster-hunter/"},{"title":"CodeCraft-21 and CF Round #711(Div.2)","text":"因为先看 C 然后直接想歪, 爆零… A. B. 没看… C. 按 $k$ 的种数统计. D. E. F. Solution 先考虑 $k = 1$ 且树高只有 $1$. (树根深度为 $0$) 那么可以发现根节点的数字没有影响, 所以就是一个 $Nim$ 游戏, 只需要把第一层的数全部异或起来看是不是零; 若树高为 $2$, 那么可以发现, 对于第一层结点异或不为 $0$ 的情况, A 只需这样控制是自己仍然可以胜利: 若 B 选取第一层的数, 那么问题和 $Nim$ 相同, 否则将 B 从第二层移向第一层的数移到根, 则又和 $Nim$ 相同. 若第一层异或和为零, B 同样可以使用类似方法控制使得问题等价于 $ Nim$. 故只需要看第一层的数的异或和即可. 对于一般的树高, 可以发现对于奇数层异或和不为零的情况, A 和 B 均可类似上文所述方法进行控制使得最后问题等价于 $Nim$. 也就是答案取决于奇数层的异或和. 对于一般的 $k$, 那么前 $(k - 1)$ 仅相当与前面的 $0$ 层, 所以可以看出就是所有 $\\mod{2k} $ 余 $k, k+1, \\ldots, 2k-1$ 的异或和. 最后使用换根dp, 需要多维护一位状态 $k$ 表示余数. 时间复杂度: $O(nk)$. Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;bits/stdc++.h&gt;using namespace std;struct Edge { int to, nxt; Edge(int _to = 0, int _nxt = 0) : to(_to), nxt(_nxt) {}};const int MAX_N = 1e5 + 7;Edge e[MAX_N &lt;&lt; 1];int head[MAX_N], dp[MAX_N][43], a[MAX_N], tmp[43];int n, k, cnt;void add(int u, int v) { e[++cnt].to = v; e[cnt].nxt = head[u]; head[u] = cnt;}void dfs(int u, int fa) { dp[u][0] = a[u]; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (v == fa) continue; dfs(v, u); for (int j = 1; j &lt;= (k &lt;&lt; 1); ++j) { dp[u][j % (k &lt;&lt; 1)] ^= dp[v][j - 1]; } }}void chr(int u, int fa) { for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (v == fa) continue; for (int j = 0; j &lt; (k &lt;&lt; 1); ++j) tmp[j] = dp[v][j]; for (int j = (k &lt;&lt; 1); j; --j) { dp[v][j % (k &lt;&lt; 1)] ^= (tmp[(j - 2 + k + k) % (k &lt;&lt; 1)] ^ dp[u][(j - 1) % (k &lt;&lt; 1)]); } chr(v, u); }}int main() { scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt; n; ++i) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); add(u, v), add(v, u); } for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i); dfs(1, 0); chr(1, 0); for (int i = 1; i &lt;= n; ++i) { int flag = 0; for (int j = k; j &lt; (k &lt;&lt; 1); ++j) flag ^= dp[i][j]; if (flag) { printf(\"1 \"); } else { printf(\"0 \"); } } puts(\"\"); return 0;}","link":"/CF/codecraft-21-and-cf-round-711-div-2/"},{"title":"Broadcast Stations","text":"题目链接 Solution 树形dp, 用 $f[u][k]$ 表示以当前点为根节点, 且当且可以向上传递 $\\geq k$ 的贡献并且其子树为全覆盖. 并用 $g[u][k]$ 表示所用距离 $u$ 小于等于 $k$ 并且将下方的所有结点覆盖的答案和的最小值. 方程转移考虑两个问题: 若当前点设置的 $p\\geq k$; 若当前点由儿子节点可以向上传递 $k$, 故可以向上传递 $k + 1$. 显然有 $g[u][k] = \\sum{g[v][k - 1]}$, $v$ 是 $u$ 的子结点. 另外对于 $f$ 的转移则为: $$ f[u][k] = min(f[u][k+1],k+g[u][k+1], f[v][k+1]+g[u][k+1]-g[v][k])(k&gt;0) $$ $$ f[u][0]=min(f[v][1]+g[u][1]-g[v][0]) $$ 时间复杂度: $O(n^2)$. Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;bits/stdc++.h&gt;using namespace std;struct Edge { int to, nxt; Edge(int _to = 0, int _nxt = 0) : to(_to), nxt(_nxt) {}};const int MAX_N = 5e3 + 7;int dp[MAX_N][MAX_N], dps[MAX_N][MAX_N], head[MAX_N];Edge e[MAX_N &lt;&lt; 1];int n, cnt;void add(int x, int y) { e[++cnt].to = y; e[cnt].nxt = head[x]; head[x] = cnt;}void dfs(int u, int fa) { for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (v == fa) continue; dfs(v, u); for (int i = 1; i &lt;= n; ++i) dps[u][i] += dps[v][i - 1]; } dp[u][n] = n; for (int k = n - 1; k &gt;= 0; --k) { if (k) dp[u][k] = min(dp[u][k + 1], k + dps[u][k + 1]); else dp[u][k] = dp[u][k + 1]; for (int i = head[u]; i; i = e[i].nxt) { int v = e[i].to; if (v == fa) continue; dp[u][k] = min(dp[u][k], dp[v][k + 1] + dps[u][k + 1] - dps[v][k]); } } dps[u][0] = dp[u][0]; for (int k = 1; k &lt;= n; ++k) dps[u][k] = min(dps[u][k], dps[u][0]);}int main() { scanf(\"%d\", &amp;n); for (int i = 1; i &lt; n; ++i) { int u, v; scanf(\"%d%d\", &amp;u, &amp;v); add(u, v); add(v, u); } dfs(1, 0); printf(\"%d\\n\", dp[1][0]); return 0;}","link":"/%E5%9B%BE%E8%AE%BA/broadcast-stations/"},{"title":"AVATAR","text":"小时候看阿凡达的时候，看了一会便觉得十分无聊，很快就关掉了。最近阿凡达重映，听同学说是一部很好的电影，特效也非常好，由于也好长时间没去看电影了，便约了同学一同去看。 电影主要讲了一个为了获取潘多拉星球某种价值连城的矿石的地球人派出主角杰克前去与当地土著人纳威人谈判，欲求让他们搬出原来地下藏有大量矿石的家园，但最后时限已到而主角已经早意识到任务不可能完成而挑起战争，于是理所当然的杰克联合纳威人将地球人赶出潘多拉星球的故事。 对于关于“采矿”的态度，地球人阵营主要有两派，一方主要代表为一看就像坏人的高层人员帕克和霸气凛然的军官库里奇，他们认为要不惜代价甚至使用暴力夺取资源；另一方是为格蕾丝为代表的科学家们，他们希望和当地人交往学习，以和平方式解决问题。而在这种背景下主角的身份我觉得恰到好处，杰克 · 萨利是一名因战争下肢瘫痪的前海军战士，他将代替其死去的科学家弟弟去完成他的使命，这是由于阿凡达是由地球人和纳威人基因创造的生物，只有杰克能够操纵由弟弟基因创造的高成本阿凡达。这样一来，他其实不是科学家，但他其实也不在是士兵，而两方的对立使他陷入矛盾的处境。一方面，库里奇信任他曾是士兵，希望他帮助他们获取纳威人的信息以方便他们发动战争；而另一方面，格蕾丝希望他能够学习他们的文化，修复两球人濒临破碎的关系。而他，在纳威民族公主的教导下，最终坠入爱河，并由前一阵营转移到后一个阵营，而这一过程发生的很自然合理。电影最后的暴力反击我觉得就是比较“美国式”的，但更注重了整体的反击，而不是只有主角这一英雄奋勇杀敌。 我觉得该电影对人物刻画非常形象，且十分合理运用了故事背景和环境。主角使一个残废了的军官，一开始我不太理解，但是后面一看就明白了——活在阿凡达身上的杰克，重新站了起来，他一醒来就迫不及待冲到了外面，不停地奔跑；而这么喜悦的他和后面形成了对比，当库里奇军官告诉他任务完成，他可以功成身退，还可以帮他的腿治好，他却很冷静地要回到纳威人身边接受成为他们一员的仪式。其他人，女主、“备胎男”、格蕾丝、部落首领等我觉得他们都各得其所，形象到位。另外在故事背景方面，纳威人是个原始的民族，得知他们被杰克欺骗时他们十分生气，将杰克绑了起来，杰克最后为了拯救纳威人制服了神兽魅影，成为当地人认为的魅影骑士，由于封建的信仰，他成功拾回纳威人的信任。这样的设置，不仅不会让人觉得突兀莫名其妙，且不会有冗余的情节，我觉得恰到好处。 除了这些感触比较深的地方之外，电影的特效方面确实做得非常好，在一个未知的星球，可以充分发挥想象力，设计各种各样奇异的东西，并且没有令人感到一种夸张到觉得很“假”的感觉，10年前，这确实是十分不容易了。因为去得晚，没办法看IMAX，最后看了Star-MAX(哈哈哈)，音效方面比较一般。其他方面，诸如男女主角发展和多处杰克第一人称独白和视频记录生活这一设置等方面都值得赏析，限于水平一般，文笔也很烂，就不说了… 最后，当然是墙裂推荐去看。","link":"/Films/avatar/"},{"title":"ARC #115","text":"觉得很有意思的一场ARC, 虽然本菜鸡只写出了3个题… A. Two Choices Problem Statement $N$ students took a test with $M$ questions with two choices: $0$ and $1$. You are given $N$ strings of length $M$ each: $S_1,S_2,…,S_N$. The $k$-th character of $S_i$ is 0 or 1, representing the response of the $i$-th student to the $k$-th question. Although we know the response of each student to each question, we do not yet know the correct answer ― $0$ or $1$ ― to each problem. Find the number of pairs $(i,j)$ satisfying $1≤i&lt;j≤N$ such that it is impossible for Student $i$ and Student $j$ to have the same number of correct answers. Constraints $2\\leq N\\leq 10^5$ $1\\leq M \\leq 20$ $S_i$ is a string of length $M$ consisting of 0 and 1 Solution 容易发现如果两个人对的题数一定不同的话等价于恰好有奇数位数字不同. 再进一步可以发现, 任意交换 0 和1 , 不同题数的奇偶性不会改变, 所以就是统计奇数个 1 和偶数个 1 的各有多少个, 然后相乘即可. Code 1234567891011121314151617181920#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_M = 27;char s[MAX_M];int n, m, cnt_odd;signed main() { scanf(\"%lld%lld\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) { scanf(\"%s\", s + 1); int cnt = 0; for (int j = 1; j &lt;= m; ++j) if (s[j] == '1') ++cnt; if (cnt &amp; 1) ++cnt_odd; } printf(\"%lld\\n\", cnt_odd * (n - cnt_odd)); return 0;} B. Plus Matrix Problem Statement Given is an $N×N$ matrix $C$ whose elements are non-negative integers. Determine whether there is a pair of sequences of non-negative integers $A_1,A_2,…,A_N$ and $B_1,B_2,…,B_N$ such that $C_{i,j}=A_i+B_j$ for every $(i,j)$. If the answer is yes, print one such pair. Constraints $1\\leq N\\leq 500$ $0\\leq C_{i,j}\\leq 10^9$ Solution 可以发现任一行任意列相邻差相同, 由此判断然后随便乱构造即可. C. $\\mathbb{N}$ Coloring Problem Statements Given is an integer $N$. Among the sequences of $N$ positive integers $A_1,A_2,…,A_N$ satisfying the following condition, print one that minimizes the maximum value in the sequence. If $i$ divides $j$, $A_i≠A_j (1≤i&lt;j≤N)$. Constraints $1\\leq N\\leq 10^5$ Solution 利用数学归纳法可以证明 $A_i = \\Omega(i) + 1$. 其中 $$ \\Omega(i) = \\alpha_1+\\alpha_2+\\ldots+\\alpha_k $$ $$ i=p_1^{\\alpha_1}p_2^{\\alpha_2}\\ldots p^{\\alpha_k} $$ Code 123456789101112131415161718192021222324#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 1e5 + 7;int n;int mx_pos(int a) { int x = a, res = 0; for (int i = 2; i * i &lt;= x; ++i) { while (x % i == 0) ++res, x /= i; } if (x &gt; 1) ++res; return res;}int main() { scanf(\"%d\", &amp;n); for (int i = 1; i &lt;= n; ++i) { printf(\"%d \", mx_pos(i) + 1); } puts(\"\"); return 0;} D. Odd Degree Problem Statements Given is a simple undirected graph with $N$ vertices and $M$ edges, where the vertices are numbered $1,…,N$ and the $i$-th edge connects Vertex $A_i$ and Vertex $B_i$. For each $K(0≤K≤N)$, find the number of spanning subgraphs (※) with exactly $K$ vertices with odd degrees. Since the answers can be enormous, print it modulo $998244353$. (※) A subgraph $H$ of $G$ is said to be a spanning subgraph of $G$ when the vertex set of $H$ equals the vertex set of $G$ and the edge set of $H$ is a subset of the edge set of $G$. Constraints $1\\leq N\\leq 5000$ $0\\leq M\\leq 5000$ $1\\leq A_i,B_i\\leq N$ The given graph is simple, that is, it contains no self-loops and no multi-edges. Solution 考虑图为一棵树的情况, 可以证明对任选的 $k$ 个固定点, 当 $k$ 为奇数时, 显然不可能存在只有 $k$ 个点的度数为奇数的情况, 这与欧拉握手定理相悖; 当 $k$ 为偶数时, 将存在唯一的子图使得这 $k$ 个点的度数恰好为奇数. 可以利用数学归纳法证明, 通过任选一个叶子结点, 进行讨论. 考虑连通图, 先任选棵图的生成树. 而其他的边不管加不加入, 其只会改变这 $k$ 个点的度数, 进而知道新的哪些具体的点度数为奇数, 并且不会改变奇度点的奇偶性. 故情况数为 $2^{m-n+1}C_{n}^{k}$. 最后对于多个连通图, 利用卷积计算总答案. 若不使用快速傅里叶变换的复杂度为 $O(n^2)$. Code 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 5e3 + 7;const int MOD = 998244353;int dp[MAX_N &lt;&lt; 1], f[MAX_N], siz_v[MAX_N], siz_e[MAX_N], tmp[MAX_N &lt;&lt; 1], tdp[MAX_N &lt;&lt; 1];int fac[MAX_N], inv_fac[MAX_N];int n, m, lst;int find(int x) { return x == f[x] ? x : f[x] = find(f[x]); }int f_pow(int base, int b, int mod = MOD) { int res = 1; while (b) { if (b &amp; 1) res = res * base % MOD; base = base * base % MOD; b &gt;&gt;= 1; } return res;}int C(int n, int m) { if (m &gt; n || m &lt; 0) return 0; return fac[n] * inv_fac[m] % MOD * inv_fac[n - m] % MOD;}signed main() { scanf(\"%lld%lld\", &amp;n, &amp;m); for (int i = 1; i &lt;= n; ++i) f[i] = i, siz_v[i] = 1; fac[0] = 1, dp[0] = 1; for (int i = 1; i &lt;= n; ++i) fac[i] = fac[i - 1] * i % MOD; inv_fac[n] = f_pow(fac[n], MOD - 2); for (int i = n - 1; i &gt;= 0; --i) inv_fac[i] = inv_fac[i + 1] * (i + 1) % MOD; for (int i = 1; i &lt;= m; ++i) { int u, v; scanf(\"%lld%lld\", &amp;u, &amp;v); int x = find(u), y = find(v); if (siz_v[x] &gt; siz_v[y]) swap(x, y); if (x != y) f[x] = y, siz_v[y] += siz_v[x], siz_e[y] += siz_e[x]; ++siz_e[y]; } for (int i = 1; i &lt;= n; ++i) { if (i == find(i)) { int e = siz_e[i], v = siz_v[i]; // printf(\"%lld %lld\\n\", e, v); for (int k = 0; k &lt;= v; ++k) { if (k &amp; 1) { tmp[k] = 0; } else { tmp[k] = f_pow(2, e - v + 1) * C(v, k) % MOD; } } // for (int j = 0; j &lt;= v; ++j) printf(\"%lld \", tmp[j]); for (int j = 0; j &lt;= lst; ++j) { tdp[j] = dp[j]; dp[j] = 0; } for (int j = 0; j &lt;= lst; ++j) { for (int k = 0; k &lt;= v; ++k) { dp[j + k] = (dp[j + k] + tdp[j] * tmp[k] % MOD) % MOD; } } lst += v; } } for (int k = 0; k &lt;= n; ++k) printf(\"%lld\\n\", dp[k]); return 0;} E. LEQ and NEQ Problem statement Given is a sequence of $N$ integers $A_1,A_2,…,A_N$. Print the number, modulo $998244353$, of sequences of $N$ integers $X_1,X_2,…,X_N$ satisfying all of the following conditions: $1≤X_i≤A_i$ $X_i≠X_{i+1}(1≤i≤N−1)$ Constraints $2\\leq N\\leq 5\\times 10^5$ $1\\leq A_i\\leq 10^9$ Solution 容斥原理, 答案为确定有 $0$ 组相邻元素相同 $-$ 确定有 $1$ 组相邻元素相同 $+$ 确定有 $2$ 组相同… 利用动态规划, 用 $f[i][k]$ 表示考虑了前 $i$ 个, 确定有 $k$ 组相同的情况数. 则有转移: f[j][k + (j - i - 1)] += f[i][k] * min(a[i + 1], a[i + 2],..., a[j]) 注意到答案恰好为所有偶数的情况减去奇数的情况, 故对上面的状态进行优化, 用 $f[i][0/1]$ 表示所有偶数的情况数和所有奇数的情况数. 这样的时间复杂度为 $O(n^2)$. 可以发现对于每一个新添加的数 $a_i$, 以 $a_i$ 作为贡献的 $f[i][k]$ 是可以知道的, 对于该区间且位于 $i$ 之前的, 其对 $f[i]$ 的贡献均为 $f$ 乘 $a_i$, 而之前的保持不变. 所以相当于在维护区间的最小值, 可以借助笛卡尔树. 将时间复杂度优化至 $O(n)$. 另外为了方便统计答案, 记 $g[i] = f[i][0] - f[i][1]$, 过程中维护一个添加了区间最小值贡献的前缀和还有一个未添加最值的前缀和. 由递归性质, 逐项符号改变, 可以设偶数项的为正, 奇数为负, 注意细节及逻辑即可. Code 1234567891011121314151617181920212223242526#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 5e5 + 7;const int MOD = 998244353;int dp[MAX_N], sum[MAX_N], sp[MAX_N], st[MAX_N], a[MAX_N];int n, top;signed main() { scanf(\"%lld\", &amp;n); dp[0] = 1; for (int i = 1; i &lt;= n; ++i) { scanf(\"%lld\", a + i); while (top &amp;&amp; a[st[top]] &gt;= a[i]) { sum[i] = (sum[i] + sum[st[top--]]) % MOD; } sum[i] = (sum[i] + (i &amp; 1 ? 1ll : -1ll) * dp[i - 1]) % MOD; dp[i] = ((i &amp; 1 ? 1ll : -1ll) * (sum[i] * a[i] % MOD + sp[st[top]])) % MOD; sp[i] = (i &amp; 1 ? 1ll : -1ll) * dp[i]; st[++top] = i; } printf(\"%lld\\n\", (dp[n] + MOD) % MOD); return 0;} F. Migration 没看…","link":"/Atcoder/arc-115/"},{"title":"CF Round #708(Div.2)","text":"很魔幻的一次 Div.2, 开局没多久CF就崩了, 后来unrated了. 数学场, 主要是一些构造, 贪心还有动态规划的题目. 比赛时候主要一直绕着 E2 在想, 后面 D 舍友想了暴力贪心的做法, 写了半天… 最后好像假了: 舍友: 你要 AC 了. Wrong answer on test 1… 舍友: 你不可能 TLE. Time limit exceeded on test 2… A. Meximization Problem 对给定序列 $a$ 进行重排成 $b$, 使得 $$ \\sum_{i = 1}^{n}mex(b_1,b_2,\\ldots,b_i) $$ 最大. ( $t(1\\leq t\\leq 100)$ 组数据, $n\\leq 100$. ) Solution 由于 $mex(b_1,\\ldots, b_i)$ 不减, 所以就是从小到大输出, 相同的数多余的排到后面即可. 时间复杂度: $O(tn\\log n)$ B. M-arrays Problem 对给定序列 $a$ 进行重排并分为多个连续段, 使得每个段中相邻两数之和必须被给定数 $m(1\\leq m\\leq 10^5)$ 整除, 求段数的最小值. (多组数据, $\\sum{n}\\leq 10^5$) Solution 对模 $m$ 的完全剩余系简单讨论计算. C1. k-LCM (easy version) Problem 对给定的 $n(3\\leq n\\leq 10^9)$, 输出三个数 $a_1,a_2,a_3$ 满足: $$ a_1+a_2+a_3=n $$ $$ LCM(a_1,a_2,a_3)\\leq \\frac{n}{2} $$ $t$ 组数据. ($t\\leq 10^4$) Solution 若为奇数, 输出 $1, (n-1)/2, (n-1)/2$; 若为偶数: 若 $n/2$ 仍为偶数, 输出 $n/2, n/4, n/4$; 否则输出 $2, (n-2)/2, (n-2)/2$. C2. k-LCM (hard version) Problem 和 C1 几乎一致, 只是要输出 $k$ 个数而不是 $3$ 个. Solution 先输出 $(k-3)$ 个 $1$, 化为上一种情况. D. Genius Problem Please note the non-standard memory limit. There are $n$ problems numbered with integers from $1$ to $n$. $i$-th problem has the complexity $c_i=2^i$, tag $tag_i$ and score $s_i$. After solving the problem $i$ it’s allowed to solve problem $j$ if and only if $IQ&lt;|c_i−c_j|$ and $tag_i≠tag_j$. After solving it your $IQ$ changes and becomes $IQ=|c_i−c_j|$ and you gain $|s_i−s_j|$ points. Any problem can be the first. You can solve problems in any order and as many times as you want. Initially your $IQ=0$. Find the maximum number of points that can be earned. Input The first line contains a single integer $t (1≤t≤100)$ — the number of test cases. The first line of each test case contains an integer $n (1≤n≤5000)$ — the number of problems. The second line of each test case contains $n$ integers $tag_1,tag_2,…,tag_n$ $(1≤tag_i≤n)$ — tags of the problems. The third line of each test case contains $n$ integers $s_1,s_2,…,s_n$ $(1≤si≤10^9)$ — scores of the problems. It’s guaranteed that sum of $n$ over all test cases does not exceed $5000$. Output For each test case print a single integer — the maximum number of points that can be earned. Solution 注意到任何两个 $2$ 的幂次数相减不可能相同, 并且被减数越大值越大. 考虑动态规划, 用 $dp[i]$ 表示最后以 $i$ 问题结尾能获得的最大价值. 那么 $i: 1\\ldots n$, 而后遍历 $j:i-1\\ldots 1$, 转移: 一个是 $i$ 可以由 $j$ 转移, 另外 $j$ 可以由 $i$ 转移. 而以这个顺序进行就会使得 $\\vert c^i-c^j\\vert$ 递增, 就是 $IQ$ 是递增的. 时间复杂度: $O(n^2)$. Code 123456789101112131415161718192021222324252627282930#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 5e3 + 7;int dp[MAX_N], tag[MAX_N], s[MAX_N];int T, n, ans;signed main() { scanf(\"%lld\", &amp;T); while (T--) { scanf(\"%lld\", &amp;n); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", tag + i); for (int i = 1; i &lt;= n; ++i) scanf(\"%lld\", s + i); for (int i = 1; i &lt;= n; ++i) dp[i] = 0; for (int i = 1; i &lt;= n; ++i) { for (int j = i - 1; j &gt; 0; --j) { if (tag[i] == tag[j]) continue; int dpi = dp[i], dpj = dp[j], v = abs(s[i] - s[j]); dp[i] = max(dp[i], dpj + v); dp[j] = max(dp[j], dpi + v); } } ans = dp[1]; for (int i = 2; i &lt;= n; ++i) ans = max(ans, dp[i]); printf(\"%lld\\n\", ans); } return 0;} E1. Square-free division (easy version) Problem This is the easy version of the problem. The only difference is that in this version $k=0$. There is an array $a_1,a_2,…,a_n$ of $n$ positive integers. You should divide it into a minimal number of continuous segments, such that in each segment there are no two numbers (on different positions), whose product is a perfect square. Moreover, it is allowed to do at most kk such operations before the division: choose a number in the array and change its value to any positive integer. But in this version $k=0$, so it is not important. What is the minimum number of continuous segments you should use if you will make changes optimally? Input The first line contains a single integer $t (1≤t≤1000)$ — the number of test cases. The first line of each test case contains two integers $n, k (1≤n≤2\\times 10^5, k=0)$. The second line of each test case contains $n$ integers $a_1,a_2,…,a_n (1≤a_i≤10^7)$. It’s guaranteed that the sum of $n$ over all test cases does not exceed $2\\times 10^5$. Output For each test case print a single integer — the answer to the problem. Solution 贪心策略, 首先预处理所有 $\\sqrt{1e7}$ 下的素数, 然后暴力质因数分解, 将素数因子的幂次为奇数的留下, 对于每个质因数可能和后面某个数相乘得到完全平方数就是后面某个数得到的素数因子序列和它相同. 暴力把素数扔进vector再套一个map. 复杂度大概为 $O(\\frac{n\\sqrt{a_{max}}}{\\log n}\\sigma{(a)}\\log n)$, 理论上不是很优秀, 但是实际跑得很快, 可能是没人卡吧. 另外其实可以直接把某个 $a$ 直接分解成 $A^2 B$, 其中 $B$ 不再有平方因子, 那么就是找后面哪个数也可以分解出一样的 $B$, 然后就要划分一次. 这样的复杂度大概是 $O(n)$ 的. Code 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 2e5 + 7;const int MAX_M = 1e7 + 7;const int MAX_P = 1e6 + 7;int pri[MAX_P];int vis[MAX_M];map&lt;vector&lt;int&gt;, bool&gt; mp;int T, n, cnt, ans, k;void Euler(int n) { for (int i = 2; i &lt;= n; ++i) { if (!vis[i]) { pri[++cnt] = i; vis[i] = true; } for (int j = 1; j &lt;= cnt &amp;&amp; i * pri[j] &lt;= n; ++j) { vis[i * pri[j]] = 1; if (i % pri[j] == 0) { break; } } }}void brute_force(int n) { int x = n, i; vector&lt;int&gt; nst; for (i = 1; pri[i] * pri[i] &lt;= n; ++i) { int tot = 0; while (x % pri[i] == 0) x /= pri[i], ++tot; if (tot &amp; 1) { nst.push_back(pri[i]); } } if (x &gt; 1) nst.push_back(x); if (mp[nst]) { ++ans; mp.clear(); } mp[nst] = true;}signed main() { Euler(1e4); scanf(\"%lld\", &amp;T); while (T--) { scanf(\"%lld%lld\", &amp;n, &amp;k); mp.clear(); ans = 1; for (int i = 1; i &lt;= n; ++i) { int a; scanf(\"%lld\", &amp;a); brute_force(a); } printf(\"%lld\\n\", ans); } return 0;} E2. square-free division (hard version) Problem $0\\leq k\\leq 20$. Solution 考虑动态规划, 用 $dp[i][j]$ 表示 $1\\ldots i$ 使用 $j$ 次变色最小分段数. 那么转移就是应该是利用 $t$ 次变色机会将 $l\\ldots i$ 变为一段进行转移. 所以我们需要预处理利用 $t$ 次机会将 $l\\ldots i$ 变为一段的 $l$, 并且尽可能最小化 $l$. 容易发现 $l$ 关于 $i$ 单调. 故利用双指针方法预处理 $O(nk)$, 总时间复杂度为 $O(nk^2)$. Code 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;bits/stdc++.h&gt;using namespace std;const int MAX_N = 2e5 + 7;const int MAX_M = 1e7 + 7;int a[MAX_N], b[MAX_M], lft[MAX_N][23], dp[MAX_N][23];unordered_map&lt;int, int&gt; cnt;int T, n, k;signed main() { for (int i = 1; i * i &lt;= 1e7; ++i) { for (int j = 1; j * i * i &lt;= 1e7; ++j) { b[j * i * i] = j; } } scanf(\"%d\", &amp;T); while (T--) { scanf(\"%d%d\", &amp;n, &amp;k); for (int i = 1; i &lt;= n; ++i) scanf(\"%d\", a + i), a[i] = b[a[i]]; for (int i = 1; i &lt;= n; ++i) { for (int j = 0; j &lt;= k; ++j) { dp[i][j] = n + 1; lft[i][j] = i; } } for (int j = 0; j &lt;= k; ++j) { int l = 1, now = 0; cnt.clear(); ++cnt[a[l]]; for (int i = 2; i &lt;= n; ++i) { if (cnt[a[i]] &gt; 0) ++now; ++cnt[a[i]]; while (now &gt; j) { if (cnt[a[l]] &gt; 1) --now; --cnt[a[l]]; ++l; } lft[i][j] = l; // printf(\"lft[%d][%d]: %d\\n\", i, j, lft[i][j]); } } for (int i = 1; i &lt;= n; ++i) { for (int j = 0; j &lt;= k; ++j) { for (int t = 0; t &lt;= j; ++t) { int l = lft[i][t]; dp[i][j] = min(dp[i][j], dp[l - 1][j - t] + 1); } } } printf(\"%d\\n\", dp[n][k]); } return 0;}","link":"/CF/cf-round-708-div-2/"},{"title":"数位DP","text":"数位DP主要用于求解 $[a,b]$ (其中 $a,b$ 很大) 中满足某一类要求的数的个数, 也就是区间计数. ABC#194.F Digits Paradise in Hexadecimal 题目大意 给定一个16进制正整数 $N(1\\leq N&lt; 16^{2\\times 10^5})$, 和一个10进制数 $K(1\\leq K\\leq 16)$, 求满足在区间 $[1, N]$ 中且各个数位数字种类个数为 $K$ 的16进制数的个数(不包括前导 $0$). 最后模一个数. 解题思路 考虑数位DP: 用 $f(pos, t, state, limit)$ 来表示状态, 其中 $pos$ 表示取到第 $i$ 位, $t$ 表示当前位数中出现数的种类数, $state$ 是一个2进制数, 用来表示当前状态选择了哪些数字, $limit$ 用来表示当前状态是否与原数的前 $i$ 位完全一致. 于是有了 $dfs$ 的版本: 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 2e5 + 7;const int MOD = 1e9 + 7;char s[MAX_N];int d[MAX_N], dp[MAX_N][17];int n, k;int dfs(int pos, int t, int limit, int state) { if (pos &gt;= n) return (t == k); if (!limit &amp;&amp; (dp[pos][t] != -1)) return dp[pos][t]; int mx = limit ? d[pos] : 15, res = 0; for (int j = 0; j &lt;= mx; ++j) { int nstate = state; if (j || state) nstate |= (1 &lt;&lt; j); res = (dfs(pos + 1, __builtin_popcount(nstate), limit &amp;&amp; (j == mx), nstate) + res) % MOD; } return limit ? res : dp[pos][t] = res;}signed main() { scanf(\"%s%lld\", s, &amp;k); n = strlen(s); for (int i = 0; i &lt; n; ++i) { if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') d[i] = s[i] - '0'; else d[i] = s[i] - 'A' + 10; } memset(dp, -1, sizeof dp); printf(\"%lld\\n\", dfs(0, 0, 1, 0)); return 0;} 另外的话, 还可以考虑非递归的版本, 用 $f[i][j]$ 表示取了 $i$ 位且当前有 $j$ 种数字出现了, 并且还满足: 取的数是严格小于原来的数 $N$ 的前 $i$ 位组成的数; 非零. 由此有递推公式, 首先由于前 $i$ 个数是严格小的, 于是新的一位可以随便填写之前出现过的 $j$ 种数字之一而转移到下一个状态 $f[i + 1][j]$, 或者同样的通过未出现过的 $(16-j)$ 种数字转移到 $f[i+1][j+1]$, 也即: $$ f[i+1][j]+=f[i][j]*j $$ $$ f[i+1][j+1]+=f[i][j]*(16-j) $$ 另外下一位不由上一位状态而来的可以是前面数字全为零, 而这时候只要随意添加一个非零数即可: $$ f[i+1][1]+=15 $$ 最后一种情况则为前 $i$ 位均与原数的前 $i$ 位相同, 那么这样的话下一位只能填 $0\\ldots d[i]-1$, 其中 $d[i]$ 即为在原数 $N$ 中的下一位数. 并且这个时候很容易就可以统计出当前状态的各数位上不同数字的个数, 然后进行转移即可. 于是有如下递推代码: 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define int long longusing namespace std;const int MAX_N = 2e5 + 7;const int MOD = 1e9 + 7;char s[MAX_N];int d[MAX_N], dp[MAX_N][17];int n, k, state;signed main() { scanf(\"%s%lld\", s, &amp;k); n = strlen(s); for (int i = 0; i &lt; n; ++i) { if (s[i] &gt;= '0' &amp;&amp; s[i] &lt;= '9') d[i] = s[i] - '0'; else d[i] = s[i] - 'A' + 10; } for (int i = 0; i &lt; n; ++i) { for (int j = 1; j &lt;= k; ++j) { dp[i + 1][j] = (dp[i + 1][j] + dp[i][j] * j % MOD) % MOD; dp[i + 1][j + 1] = (dp[i + 1][j + 1] + dp[i][j] * (16 - j) % MOD) % MOD; } if (i) dp[i + 1][1] = (dp[i + 1][1] + 15) % MOD; for (int j = 0; j &lt; d[i]; ++j) { int nstate = state; if (i || j) nstate |= (1 &lt;&lt; j); int st = __builtin_popcount(nstate); dp[i + 1][st] = (dp[i + 1][st] + 1) % MOD; } state |= (1 &lt;&lt; d[i]); } int st = __builtin_popcount(state); dp[n][st] = (dp[n][st] + 1) % MOD; printf(\"%lld\\n\", dp[n][k]); return 0;} 比较 正常来说, 所谓 $dfs$ 版本其实就是记忆化搜索版本的动态规划, 理论上状态数会比较少(略去了无用的状态), 但是另一方面其常数会比较大. 一般情况(个人经验), $dfs$ 效率较优, 但是对于此题, 数位高达 $2e5$, 递归反而更慢, 采取递推方式较好.","link":"/DP/%E6%95%B0%E4%BD%8Ddp/"},{"title":"tarjan算法求SCC/BCC","text":"SCC HDU 1269 迷宫城堡 12345678910111213141516171819202122void tarjan(int u) { dfn[u] = low[u] = ++order; st.push(u); for(int i = head[u]; i; i = e[i].next) { int v = e[i].to; if(!dfn[v]) { tarjan(v); low[u] = min(low[u], low[v]); } else if(dfn[v] &lt; dfn[u]) { low[u] = min(low[u], dfn[v]); } } if(dfn[u] == low[u]) { int num = 0, tmp; do { tmp = st.top(); st.pop(); num++; }while(tmp != u); mx = max(mx, num); }} 割点 洛谷 P3388 【模板】割点（割顶） 1234567891011121314151617181920void tarjan(int u, int fa) { dfn[u] = low[u] = ++order; int child = 0; for(int i = head[u]; i; i = e[i].next) { int v = e[i].to; if(v == fa) continue; if(!dfn[v]) { child++; tarjan(v, u); low[u] = min(low[u], low[v]); if(low[v] &gt;= dfn[u] &amp;&amp; fa) { if(!point[u]) point[u] = true, ans++; } else if(!fa &amp;&amp; child &gt; 1) { if(!point[u]) point[u] = true, ans++; } } else if(dfn[v] &lt; dfn[u]) { low[u] = min(low[u], dfn[v]); } }} 点双连通分量 hihoCoder 连通性·四 123456789101112131415161718192021222324252627void tarjan(int u, int fa) { dfn[u] = low[u] = ++order; for(int i = head[u]; i; i = e[i].next) { int v = e[i].to; if(v == fa) continue; if(!dfn[v]) { int id = e[i].index; st.push(id); tarjan(v, u); low[u] = min(low[u], low[v]); if(low[v] &gt;= dfn[u]) { num++; mn[num] = INF; int tmp; do { tmp = st.top(); belong[tmp] = num; st.pop(); mn[num] = min(mn[num], tmp); }while(tmp != id); } } else if(dfn[v] &lt; dfn[u]) { st.push(e[i].index); low[u] = min(low[u], dfn[v]); } }} 边双连通分量及桥 洛谷 T102489 【模板】边双连通分量 POJ Redundant Paths 1234567891011121314151617181920212223242526272829303132void tarjan(int u, int fa) { dfn[u] = low[u] = ++order; bool flag = true; st.push(u); for(int i = head[u]; i; i = e[i].next) { int v = e[i].to; if(v == fa &amp;&amp; flag) { flag = false; continue; } if(!dfn[v]) { tarjan(v, u); low[u] = min(low[u], low[v]); if(low[v] &gt; dfn[u]) { bridge[i] = 1; if(i &amp; 1) bridge[i + 1] = 1; else bridge[i - 1] = 1; } } else if(dfn[v] &lt; dfn[u]) { low[u] = min(low[u], dfn[v]); } } if(dfn[u] == low[u]) { num++; int tmp; do{ tmp = st.top(); belong[tmp] = num; st.pop(); }while(tmp != u); }}","link":"/%E5%9B%BE%E8%AE%BA/tarjan%E7%AE%97%E6%B3%95%E6%B1%82scc-bcc/"},{"title":"绝对值最值","text":"题目 记 $(x_1,x_2,\\ldots,x_{20})$ 是 $(1,2,3,\\ldots,20)$ 的一个排列，并记 $$ S=\\sum_{i=1}^{20}\\vert x_i-i\\vert $$ 求 $S$ 的最值． 分析及解答 首先最小值我相信大家都能看出来，是零．只需要取 $$ x_i=i $$ 即可，并且结合 $S\\geq 0$ 即证． 所以关键问题在于最大值的求解．由于 $x_i$ 与 $i$ 的关系难以直接判断，造成难以继续下一步处理，其实大家应该也能猜到，其实我们可以有一种贪心的策略．什么意思呢，就是我按 $1,2,\\ldots,20$ 的顺序依次确定 $x_i$，而我每次取的时候都让 $\\vert x_i-i\\vert$ 尽可能的大，也就是这样： $i=1$ 时，取 $x_1=20$，则使得 $\\vert x_1-1\\vert$ 最大化； $i=2$ 时，由于这个时候 $20$ 已经被取过，于是取 $x_2=19$ ； $x_3=18$； $\\ldots$ $i=8$ 时，这时候有点问题，因为按上面的规律理应当取 $x_8=13$，但是很明显有 $$ \\vert 13-8\\vert=5&lt;\\vert 1-8\\vert $$ 也就是应当取 $x_8=1$； 接下来则都遵循 $x_i=i-7$，换言之 $\\vert x_i-i\\vert=7$． 那么取完之后可以计算一下结果： $$ \\begin{align*} S&=\\sum_{i=1}^{7}\\vert x_i-i\\vert+\\sum_{i=8}^{20}\\vert x_i-i\\vert\\\\ &=\\sum_{i=1}^{7}((21-i)-i)+7\\times (20-8+1)\\\\ &=21\\times 7-7\\times 8+7\\times 13\\\\ &=182 \\end{align*} $$ 但是这样好像有点问题，也的确证明不了是最大值，因为虽然越前面越大，但是后面好像却变小了．并且注意，这个方法还挺繁琐，竟然还要分类讨论．其实我们可以很容易联想到另外一个猜测，就是 $(x_1,x_2,\\ldots,x_{20})$ 刚好和原序列反过来，也就是 $$ (20,19,\\ldots,2,1) $$ 那先算一下答案，由对称性： $$ \\begin{align*} S&=2\\sum_{i=1}^{10}\\vert x_i-i\\vert\\\\ &=2(\\sum_{i=11}^{20}i-\\sum_{i=1}^{10}i)\\\\ &=21\\times 10-11\\times 10\\\\ &=200 \\end{align*} $$ 一看就会觉得这个答案靠谱很多．那到底是不是最大值呢？ 首先我们要说明这个问题的第一个障碍就是绝对值，为了方便观察，可以进行如下转换，注意到： $$ \\vert a-b\\vert=\\max\\{a,b\\}-\\min\\{a,b\\} $$ 意思就是说在 $\\vert x_i-i\\vert$ 中，$x_i$ 必定会作为 $\\max$ 或者是 $\\min$，剩下的就是 $i$．这样处理可以给我们一个全局的思考方向．因为 $x_i$ 还有 $i$ 其实都是 $1-20$ 之间的某一个数，也就是说对于任何一个 $i\\in {1,2,\\ldots,20}$，必定在 $\\max$ 或 $\\min$ 中出现两次．所以要最大化，只需要 $i&gt;10$ 时全部取到 $\\max$，$i&lt;11$ 时全部取到 $\\min$．也就是 $$ \\begin{align*} S&amp;\\leq2(\\sum_{i=11}^{20}i-\\sum_{i=1}^{10}i)\\ &amp;=200 \\end{align*} $$ 故最大值就是 $200$． 题外话 实际上一旦发现这点后可以知道 当 $i10$ 时，取 $x_i\\in\\{1,2,\\ldots,10\\}$． 啥意思？就是有 $(10!)^2$ 种取法．","link":"/%E6%95%B0%E5%AD%A6/%E7%BB%9D%E5%AF%B9%E5%80%BC%E6%9C%80%E5%80%BC/"},{"title":"luogu P2801 教主的魔法","text":"题目：P2801 教主的魔法 题目描述 教主最近学会了一种神奇的魔法，能够使人长高。于是他准备演示给XMYZ信息组每个英雄看。于是N个英雄们又一次聚集在了一起，这次他们排成了一列，被编号为1、2、……、N。 每个人的身高一开始都是不超过1000的正整数。教主的魔法每次可以把闭区间[L, R]（1≤L≤R≤N）内的英雄的身高全部加上一个整数W。（虽然L=R时并不符合区间的书写规范，但我们可以认为是单独增加第L（R）个英雄的身高） CYZ、光哥和ZJQ等人不信教主的邪，于是他们有时候会问WD闭区间 [L, R] 内有多少英雄身高大于等于C，以验证教主的魔法是否真的有效。 WD巨懒，于是他把这个回答的任务交给了你。 输入格式 第1行为两个整数N、Q。Q为问题数与教主的施法数总和。 第2行有N个正整数，第i个数代表第i个英雄的身高。 第3到第Q+2行每行有一个操作： （1） 若第一个字母为“M”，则紧接着有三个数字L、R、W。表示对闭区间 [L, R] 内所有英雄的身高加上W。 （2） 若第一个字母为“A”，则紧接着有三个数字L、R、C。询问闭区间 [L, R] 内有多少英雄的身高大于等于C。 输出格式 对每个“A”询问输出一行，仅含一个整数，表示闭区间 [L, R] 内身高大于等于C的英雄数。 输入输出样例 输入 #1 1234567895 31 2 3 4 5A 1 5 4M 3 5 1A 1 5 4 输出 #1 1223 说明/提示 【输入输出样例说明】 原先5个英雄身高为1、2、3、4、5，此时[1, 5]间有2个英雄的身高大于等于4。教主施法后变为1、2、4、5、6，此时[1, 5]间有3个英雄的身高大于等于4。 【数据范围】 对30%的数据，N≤1000，Q≤1000。 对100%的数据，N≤1000000，Q≤3000，1≤W≤1000，1≤C≤1,000,000,000。 分析 刚入门分块，以此作为练习。 初始化：将数组拆为 $\\sqrt{n}$ 个区间，查询时，如果区间覆盖了一个块，则直接输出块的答案。显然这样做最多只有两个块需要单独操作。 查询：本题不是查询区间和，为方便查找大于 $c$ 的数目，再用另外一个数组 $t[]$ 对区间进行排序，查询时利用二分查找即可。 区间增加：对于一整个区间被覆盖的情况，用 $dlt[]$ 数组将整个区间加上 $w$。边界处暴力增加。 时间复杂度：$O(Q\\sqrt{N}\\log N)$。 代码(C++) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;iostream&gt;#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;cmath&gt;using namespace std;namespace iNx{ const int N = 1e6 + 7 ; const int SQN = 1e3 + 7 ; int a[N],t[N],st[SQN],ed[SQN],belong[N],size[SQN],dlt[SQN]; int n,q; void SORT(int x){ for(int i=st[x];i&lt;=ed[x];i++) t[i]=a[i]; sort(t+st[x],t+ed[x]+1); } void init(){ int num=sqrt(n); int i,j; for(i=0;i&lt;num;i++){ st[i+1]=n/num * i + 1; ed[i+1]=n/num * (i+1); } ed[num]=n; for(i=1;i&lt;=num;i++){ SORT(i); for(j=st[i];j&lt;=ed[i];j++) belong[j]=i; size[i]=ed[i]-st[i]+1; } } void modify(int l,int r,int c){ int x=belong[l],y=belong[r],i; if(x==y){ for(i=l;i&lt;=r;i++) a[i]+=c; SORT(x); return ; } for(i=l;i&lt;=ed[x];i++) a[i]+=c; for(i=st[y];i&lt;=r;i++) a[i]+=c; for(i=x+1;i&lt;y;i++) dlt[i]+=c; SORT(x); SORT(y); } int BF(int l,int r,int c,int x){ int ans=r+1,L=l,R=r,mid; while(L&lt;=R){ mid=(L+R)&gt;&gt;1; if(t[mid]+dlt[x]&gt;=c) ans=mid,R=mid-1; else L=mid+1; } return (r-ans+1); } int answer(int l,int r,int c){ int i,ans=0; int x=belong[l],y=belong[r]; if(x==y) return BF(l,r,c,x); ans+=BF(l,ed[x],c,x); ans+=BF(st[y],r,c,y); for(i=x+1;i&lt;y;i++) ans+=BF(st[i],ed[i],c,i); return ans; } void work(){ scanf(\"%d%d\",&amp;n,&amp;q); int i,l,r,c; char ch; for(i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); init(); for(i=1;i&lt;=q;i++){ ch=cin.peek(); while(ch==' '||ch=='\\n'||ch=='\\r'){ cin.get(); ch=cin.peek(); } ch=cin.get(); if(ch=='A'){ scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;c); printf(\"%d\\n\",answer(l,r,c)); } else if(ch=='M'){ scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;c); modify(l,r,c); } } }}int main(){ iNx::work(); return 0;}","link":"/%E5%88%86%E5%9D%97/luogu-p2801-%E6%95%99%E4%B8%BB%E7%9A%84%E9%AD%94%E6%B3%95/"},{"title":"KMP算法","text":"HDU 1711 Number Sequence Time Limit: 10000/5000 MS (Java/Others) Memory Limit: 32768/32768 K (Java/Others) Total Submission(s): 57954 Accepted Submission(s): 23132 Problem Description Given two sequences of numbers : a[1], a[2], … , a[N], and b[1], b[2], … , b[M] (1 &lt;= M &lt;= 10000, 1 &lt;= N &lt;= 1000000). Your task is to find a number K which make a[K] = b[1], a[K + 1] = b[2], … , a[K + M - 1] = b[M]. If there are more than one K exist, output the smallest one. Input The first line of input is a number T which indicate the number of cases. Each case contains three lines. The first line is two numbers N and M (1 &lt;= M &lt;= 10000, 1 &lt;= N &lt;= 1000000). The second line contains N integers which indicate a[1], a[2], … , a[N]. The third line contains M integers which indicate b[1], b[2], … , b[M]. All integers are in the range of [-1000000, 1000000]. Output For each test case, you should output one line which only contain K described above. If no such K exists, output -1 instead. Sample Input 1234567213 51 2 1 2 3 1 2 3 1 3 2 1 21 2 3 1 313 51 2 1 2 3 1 2 3 1 3 2 1 21 2 3 2 1 Sample Output 126-1 Source HDU 2007-Spring Programming Contest 代码 ++1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;iostream&gt;#include&lt;cstdio&gt;using namespace std;namespace iNx{ const int N = 1e6 + 10 ; const int M = 1e4 + 10 ; int a[N],b[M],next[M]; int n,m; void init(){ int i,k; for(i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); for(i=0;i&lt;m;i++) scanf(\"%d\",&amp;b[i]); next[0]=-1; i=0; k=-1; while(i&lt;m-1){ if(k==-1||b[i]==b[k]){ i++; k++; if(b[i]!=b[k]) next[i]=k; else next[i]=next[k]; } else k=next[k]; } } void work(){ scanf(\"%d%d\",&amp;n,&amp;m); if(n&lt;m){ printf(\"-1\\n\"); return ; } init(); int i=0,j=0; while(i&lt;n&amp;&amp;j&lt;m){ if(j==-1||a[i]==b[j]) i++,j++; else j=next[j]; } if(j==m) printf(\"%d\\n\",i-j+1); else printf(\"-1\\n\"); }}int main(){ int T; scanf(\"%d\",&amp;T); while(T--) iNx::work(); return 0;}","link":"/%E5%AD%97%E7%AC%A6%E4%B8%B2/kmp%E7%AE%97%E6%B3%95/"},{"title":"简单的偏微分方程（练习题）","text":"例题 已知微分方程 $$ \\frac{\\partial^2 u}{\\partial x^2}+\\frac{\\partial^2 u}{\\partial y^2}=0 $$ 有形如 $u=\\varphi(\\frac{y}{x})$ 的解，试求此解． 解 因为 $$ \\begin{align*} &\\frac{\\partial u}{\\partial x}=-\\frac{y}{x^2}\\varphi'\\\\ &\\frac{\\partial^2 u}{\\partial x^2}=2\\frac{y}{x^3}\\varphi'+\\frac{y^2}{x^4}\\varphi''\\\\ &\\frac{\\partial u}{\\partial y}=\\frac{1}{x}\\varphi'\\\\ &\\frac{\\partial^2 u}{\\partial y^2}=\\frac{1}{x^2}\\varphi'' \\end{align*} $$ 得到 $$ 2\\frac{y}{x^3}\\varphi’+\\frac{y^2}{x^4}\\varphi’’+\\frac{1}{x^2}\\varphi’’=0 $$ 很明显，两边同乘 $x^2$ 并令 $t=\\frac{y}{x}$ 即可化为常微分方程 $$ 2t\\varphi’+(t^2+1)\\varphi’’=0 $$ 这是一个一阶齐次线性微分方程，其实可以看出 $$ [(t^2+1)\\varphi’]’=0 $$ 于是 $$ \\varphi’=\\frac{C_1}{t^2+1} $$ 进一步积分得到 $$ \\varphi=C_1\\arctan{\\frac{y}{x}}+C_2 $$ 例题 设 $u=u(\\sqrt{x^2+y^2})$ 具有连续二阶偏导数，且满足 $$ \\frac{\\partial^2 u}{\\partial x^2}+\\frac{\\partial^2 u}{\\partial x^2}-\\frac{1}{x}\\cdot\\frac{\\partial u}{\\partial x}+u=x^2+y^2 $$ 求 $u$． 解 同样的计算 $u$ 的偏导数及二阶偏导数，并令 $t=\\sqrt{x^2+y^2}$ 将其化为常微分方程得： $$ u’’+u=t^2 $$ 其齐次通解为 $$ C_1\\cos t+C_2\\sin t $$ 容易求得一个特解 $$ y_p=t^2-2 $$ 将 $t=\\sqrt{x^2+y^2}$ 代入即可．","link":"/%E7%BB%83%E4%B9%A0%E9%A2%98/%E7%AE%80%E5%8D%95%E7%9A%84%E5%81%8F%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%EF%BC%88%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%89/"},{"title":"ODE常微分方程的微分算子法（1）","text":"常微分方程的微分算子法 定义 定义微分算子符号 $D^n=\\frac{d^n}{dx^n}$，则二阶线性微分方程 $$ y’’+Ay’+By=f(x) $$ 可以写成 $$ (D^2+AD+B)y=f(x) $$ 记多项式 $P(x)=x^2+Ax+B$，则又可以写成 $$ P(D)y=f(x) $$ 指数型 代换法则 描述 $$ P(D)e^{\\alpha x}=P(\\alpha)e^{\\alpha x} $$ $\\alpha$ 为复数． 证明 显然等价于证明 $$ D^n e^{\\alpha x}=\\alpha^n e^{\\alpha x} $$ 而这是显然的． 指数输入定理 描述 若 $P(D)y=e^{\\alpha x}$，则 $$ y_p=\\frac{e^{\\alpha x}}{P(\\alpha)}(while\\ P(\\alpha)\\neq0) $$ 其中 $y_p$ 表示一个特解． 证明 只需讲 $y_p$ 代入验证是方程的解即可，由代换法则 $$ \\begin{align*} P(D)y_p=&P(D)\\frac{e^{\\alpha x}}{P(\\alpha)}\\\\ =&\\frac{P(\\alpha)e^{\\alpha x}}{P(\\alpha)}\\\\ =&e^{\\alpha x} \\end{align*} $$ 证毕． 例题 求微分方程 $$ y’’-y’+2y=10e^{-x}\\sin x $$ 解： 先将方程复化 $$ (D^2-D+2)\\tilde{y}=10e^{(-1+i)x} $$ 方程特解 $y_p$ 即为 $\\tilde{y}_p$ 的虚部，由指数输入定理 $$ \\begin{align*} \\tilde y_p&=\\frac{10e^{(-1+i)x}}{(-1+i)^2-(-1+i)+2}\\\\ &=\\frac{10e^{(-1+i)x}}{-2i+1-i+2}\\\\ &=\\frac{10e^{-x}(\\cos x+i\\sin x)}{3-3i}\\\\ &=\\frac{10}{6}(1+i)e^{-x}(\\cos x+i\\sin x)\\\\ \\end{align*} $$ 因此，$y_p=$ $$ \\frac{5}{3}e^{-x}(\\sin x+\\cos x) $$ 那么如果 $p(\\alpha)=0$ 呢？ 指数移位法则 为与上面的情况区分，下面不再写 $\\alpha$ 而是 $a$，但是 $a$ 仍然可以是复数． 描述 $$ P(D)e^{ax}u(x)=e^{ax}P(D+a)u(x) $$ 证明 利用数学归纳法并且与代换法则相同，等价于证明单个算子的情况，即 $$ D^ne^{ax}u(x)=e^{ax}(D+a)^n u(x) $$ 在不引起歧义的前提下，下面将 $u(x)$ 写成 $u$ 而不影响理解． （1）当 $n=1$ 时 $$ D e^{ax}u=ae^{ax}u+e^{ax}Du=e^{ax}(D+a)u $$ 所以当 $n=1$ 时该法则正确． （2）当 $n=k-1$ 时成立 $$ \\begin{align*} D^ke^{ax}u&=D(D^{k-1}e^{ax}u)\\\\ &=D(e^{ax}(D+a)^{k-1}u)\\\\ &=e^{ax}(D+a)^ku \\end{align*} $$ 证毕． 一般性结论 首先来看二阶微分方程． 单根 若 $P(a)=0$ 且 $a$ 是单根，则有 $$ y_p=\\frac{xe^{ax}}{P’(a)} $$ 证明 因为 $a$ 是 $P(D)$ 的一个根，所以可以设 $$ P(D)=(D-a)(D-b) (a\\neq b) $$ 因此 $$ P’(D)=D-a+D-b $$ 也即 $$ P’(a)=a-b $$ 代入以检验解 $y_p$ 的正确性 $$ P(D)\\frac{e^{ax}x}{P’(a)}=\\frac{e^{ax}(D-b-a)Dx}{P’(a)}=\\frac{e^{ax}(a-b)}{(a-b)}=e^{ax} $$ 证毕． 二重根 若 $a$ 是二重根，则有 $$ y_p=\\frac{x^2e^{ax}}{P’’(a)} $$ 证明与前一种类似，设 $P(D)=(D-a)^2$ 进行检验即可． 例题 求 $$ y’’-3y+2y=e^x $$ 的特解． 解： $$ P(D)=D^2-3D+2 $$ $a=1$ 是单根（一重根），所以 $$ y_p=\\frac{xe^x}{P’(1)}=\\frac{xe^{x}}{2-3}=-xe^x $$ 更一般方程和 $n$ 重根 由前面两个例子，其实可以猜出： 当 $a$ 是 $n$ 重根时 $$ y_p=\\frac{e^{ax}x^n}{P^{(n)}(a)} $$ 其实将 $P(D)$ 理解为 $P^{(0)}(D)$，则上述结论为一般性结论，适用于任何情况． 证明 和前面的思路其实类似，关键在于怎么表示 $P(D)$ 已提取对我们最有利的部分． 设 $$ P(D)=(D-a)^n \\tilde{P}(D) $$ 则 $$ P^{(n)}(D)=n!\\tilde P(D)+(D-a)A(D) $$ 其中，$A(D)$ 是关于 $D$ 的多项式，可以看出来 $$ P^{(n)}(a)=n!\\tilde P(a) $$ 将 $y_p$ 代入方程检验 $$ \\begin{align*} P(D)\\frac{e^{ax}x^n}{P^{(n)(a)}}=&\\frac{e^{ax}P(D+a)x^n}{P^{(n)}(a)}\\\\ =&\\frac{e^{ax}\\tilde P(D+a)D^n x^n}{n! \\tilde P(a)}\\\\ =&\\frac{e^{ax}\\tilde P(D+a)\\times n!}{n! \\tilde P(a)}\\\\ =&\\frac{e^{ax}\\tilde P(a)\\times n!}{n! \\tilde P(a)}\\\\ =&e^{ax} \\end{align*} $$ 结语 在网上可以找到的算子法本就少之又少，大部分又只重结论，云里雾里，还需要多记很多麻烦的情况．例如三角函数，但是实际上只需要将三角函数复化就可以用指数的形式轻松解决，最后其实就只有一个公式．这次先谈到这，读者可以再多思考并做一些练习尝试，下次我再介绍 $f(x)$ 为多项式的情况．","link":"/%E6%95%B0%E5%AD%A6/ode%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E7%9A%84%E5%BE%AE%E5%88%86%E7%AE%97%E5%AD%90%E6%B3%95%EF%BC%881%EF%BC%89/"},{"title":"取值范围","text":"题目 函数 $f(x)=\\sqrt{2x-x^2}+x$ 的值域为____． 思考ing… 分析与解答 解法一 三角换元 注意到 $$ \\sqrt{2x-x^2}=\\sqrt{1-(x-1)^2} $$ 所以设 $x-1=\\sin \\alpha(\\alpha\\in[-\\frac{\\pi}{2},\\frac{\\pi}{2}])$，则 $f(x)=\\cos\\alpha+(1+\\sin\\alpha)$．于是 $$ \\begin{align*} f(x)&=1+\\sin\\alpha+\\cos\\alpha\\\\ &=1+\\sqrt{2}\\sin(\\alpha+\\frac{\\pi}{4})\\\\ &\\in[0,\\sqrt{2}+1] \\end{align*} $$ 解法二 柯西不等式 因为 $$ 1-(x-1)^2\\geq0\\Rightarrow x\\in[0,2] $$ 所以 $f(x)\\geq 0$，并且注意到，当 $x=0$ 时 $$ f(1)=0 $$ 即 $f(x)$ 最小值为 $0$． 另一方面，由柯西不等式 $$ \\begin{align*} f(x)&=\\sqrt{1-(x-1)^2}+x-1+1\\\\ &\\leq\\sqrt{(1-(x-1)^2+(x-1)^2)(1+1)}+1\\\\ &=\\sqrt{2}+1 \\end{align*} $$ 题外话 对于有根式和正常多项式的问题，三角和柯西不等式往往都能解决．可以权衡一下，找到更适合自己的方法．","link":"/%E7%BB%83%E4%B9%A0%E9%A2%98/%E5%8F%96%E5%80%BC%E8%8C%83%E5%9B%B4/"},{"title":"根式有理化","text":"问题来源 初中的时候曾经做过一道题, 题目具体是什么记不起来了. 记得最后发现用三角函数和用勾股定理得到的答案竟然不相同! 用三角函数计算得到的答案: $$ \\frac{\\sqrt{10}+\\sqrt{2}}{2} $$ 而用勾股定理开方算出来的是 $$ \\sqrt{3+\\sqrt{5}} $$ 当时考完听说有两答案还不信, 觉得是别人算错了, 结果自己一算还真是两个答案. 按计算器化简不出来, 但是求出估计值是一样的. 后面老师讲题也说其实两个都对, 这… 到底是为什么? 于是又去认真化了一下, 发现 $$ \\begin{align*} \\sqrt{3+\\sqrt{5}}=&\\sqrt{\\frac{6+2\\sqrt{5}}{2}} \\\\ =&\\sqrt{\\frac{(\\sqrt{5}+1)^2}{2}} \\\\ =&\\frac{\\sqrt{5}+1}{\\sqrt{2}} \\\\ =&\\frac{\\sqrt{10}+\\sqrt{2}}{2} \\end{align*} $$ 其实在这之前已经有遇到类似的例子, 比如 $$ \\sqrt{4-2\\sqrt{3}}=\\sqrt{3}-1 $$ 这些情况往往都一下子就看出来了, 为什么这道题却栽了跟头? 最主要的可能就是需要上下同乘 $2$ 才能比较直观地看出来可以配方. 所以觉得是不是当配不出来的时候就要上下同乘继续观察呢? 再看这个例子: $$ \\sqrt{5+\\sqrt{3}} $$ 能不能化简出来呢? 读者可以试一下, 但是可以发现这个尝试是无休止的. 但是还是不能说就不能. 思考与解决 所以接下来想的就是, 到底能不能有一个方法来判定能不能化简, 那么就可以省去许多尝试的时间. 所以我们需要建立一个一般情况的模型: $$ \\sqrt{x+\\sqrt{y}}=\\sqrt{a}+\\sqrt{b} $$ 其中 $a,b$ 不为根式, 求 $x,y$ 需要满足的条件. 为了更好地进行下一步分析, 我们再做一些处理. 对于 $\\sqrt{2-\\sqrt{3}}$, 由于其是 $\\frac{\\sqrt{4-2\\sqrt{3}}}{\\sqrt{2}}$ 可知能够化简. 也就是说对于任何的根式套根式, 必定能够利用通分, 化为 $$ \\frac{\\sqrt{x\\pm\\sqrt{y}}}{\\sqrt{z}} $$ 其中 $x,y,z$ 均为正整数. $\\sqrt{z}$ 显然不会影响化简, 所以问题等价于 $$ \\sqrt{x\\pm\\sqrt{y}} $$ 能否化简, 以分式类比, 我称其为&quot;根式有理化&quot;. 接下来进行我们的分析: 注意到: 如果有 $\\sqrt{x+\\sqrt{y}}=\\sqrt{a}+\\sqrt{b}$, 那么显然有 $\\sqrt{x-\\sqrt{y}}=\\sqrt{a}-\\sqrt{b}$. (记 $a&gt;b$)这对称性能不能带来帮助呢? 将其平方并写在一起进行观察: $$ \\begin{gather} x+\\sqrt{y}=a+b+2\\sqrt{ab}\\\\ x-\\sqrt{y}=a+b-2\\sqrt{ab} \\end{gather} $$ (1)+(2) 得 $$ a+b=x $$ (1)-(2) 得 $$ ab=\\frac{y}{4} $$ 也就是说, $a,b$ 是方程 $$ z^2-xz+\\frac{y}{4}=0 $$ 的两个根, 由于 $a,b$ 均为正整数, 故 $$ \\sqrt{\\Delta}=\\sqrt{x^2-y} $$ 必须为某个正整数 $N$, 也即 $x^2-y=N^2$ 是一个完全平方数. 至此已经得到了可以根式有理化的必要条件. 实际上, 这个条件不只是必要. 因为 $\\Delta$ 确定了, 其实两根 $a,b$ 也就确定了: $$ \\begin{cases} a=\\frac{x+N}{2} \\ b=\\frac{x-N}{2} \\end{cases} $$ 至此完全地解决了这个问题. 在此说一下一些初次尝试的人会犯的错, 比如 $$ \\sqrt{\\sqrt{13}-3} $$ 因为 $13-9=4$ 是完全平方数, 所以可以根式有理化? 这是不行的, 一定是带根号的比较小, 注意前面我们的证明.","link":"/%E6%95%B0%E5%AD%A6/%E6%A0%B9%E5%BC%8F%E6%9C%89%E7%90%86%E5%8C%96/"}],"tags":[{"name":"KMP","slug":"KMP","link":"/tags/KMP/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"微分方程","slug":"微分方程","link":"/tags/%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B/"},{"name":"图论","slug":"图论","link":"/tags/%E5%9B%BE%E8%AE%BA/"},{"name":"数位DP","slug":"数位DP","link":"/tags/%E6%95%B0%E4%BD%8DDP/"},{"name":"ODE","slug":"ODE","link":"/tags/ODE/"},{"name":"练习题","slug":"练习题","link":"/tags/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"分块","slug":"分块","link":"/tags/%E5%88%86%E5%9D%97/"},{"name":"CF","slug":"CF","link":"/tags/CF/"},{"name":"Atcoder","slug":"Atcoder","link":"/tags/Atcoder/"},{"name":"Films","slug":"Films","link":"/tags/Films/"},{"name":"DP","slug":"DP","link":"/tags/DP/"},{"name":"Tree DP","slug":"Tree-DP","link":"/tags/Tree-DP/"},{"name":"背包","slug":"背包","link":"/tags/%E8%83%8C%E5%8C%85/"},{"name":"概率论","slug":"概率论","link":"/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"},{"name":"二分答案","slug":"二分答案","link":"/tags/%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88/"},{"name":"数论","slug":"数论","link":"/tags/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","link":"/tags/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"贪心","slug":"贪心","link":"/tags/%E8%B4%AA%E5%BF%83/"},{"name":"位运算","slug":"位运算","link":"/tags/%E4%BD%8D%E8%BF%90%E7%AE%97/"},{"name":"Moebius transform","slug":"Moebius-transform","link":"/tags/Moebius-transform/"},{"name":"状压DP","slug":"状压DP","link":"/tags/%E7%8A%B6%E5%8E%8BDP/"},{"name":"递推","slug":"递推","link":"/tags/%E9%80%92%E6%8E%A8/"},{"name":"PE","slug":"PE","link":"/tags/PE/"}],"categories":[{"name":"练习题","slug":"练习题","link":"/categories/%E7%BB%83%E4%B9%A0%E9%A2%98/"},{"name":"数学","slug":"数学","link":"/categories/%E6%95%B0%E5%AD%A6/"},{"name":"图论","slug":"图论","link":"/categories/%E5%9B%BE%E8%AE%BA/"},{"name":"DP","slug":"DP","link":"/categories/DP/"},{"name":"字符串","slug":"字符串","link":"/categories/%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"name":"分块","slug":"分块","link":"/categories/%E5%88%86%E5%9D%97/"},{"name":"CF","slug":"CF","link":"/categories/CF/"},{"name":"Atcoder","slug":"Atcoder","link":"/categories/Atcoder/"},{"name":"Films","slug":"Films","link":"/categories/Films/"},{"name":"Templates","slug":"Templates","link":"/categories/Templates/"},{"name":"CS: APP","slug":"CS-APP","link":"/categories/CS-APP/"},{"name":"数论","slug":"数论","link":"/categories/%E6%95%B0%E8%AE%BA/"},{"name":"组合数学","slug":"组合数学","link":"/categories/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6/"},{"name":"PE","slug":"PE","link":"/categories/PE/"}]}